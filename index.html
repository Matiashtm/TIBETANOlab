<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Caja de Ritmos - Mini DAW (Todo en 1)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --bg:#071018; --panel:#0f1820; --accent:#6b9cff; --text:#e8eef5; --muted:#9fb4c8;
  --ok:#2ecc71; --danger:#ff5a5f; --radius:12px;
}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#071018,#08121a);color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial;height:100vh;display:flex;flex-direction:column}
header{display:flex;align-items:center;padding:10px 14px;gap:8px;background:rgba(255,255,255,0.02);border-bottom:1px solid rgba(255,255,255,0.03)}
.brand{font-weight:700}
.buttons{margin-left:auto;display:flex;gap:8px}
.btn{padding:8px 12px;border-radius:10px;background:#0c1620;border:1px solid #18324a;color:var(--text);cursor:pointer}
.main{flex:1;display:grid;grid-template-columns:240px 1fr;gap:12px;padding:12px;align-items:stretch}
.left{background:var(--panel);padding:12px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.03);overflow:auto}
.left h3{margin:0 0 8px 0;color:var(--muted);font-size:13px}
.row-btn{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:10px;background:#08121a;border:1px dashed rgba(255,255,255,0.02);margin-bottom:8px;cursor:pointer}
.row-btn:hover{border-style:solid;border-color:#234a76}
.center{display:flex;flex-direction:column;gap:10px}
.controls{display:flex;gap:8px;align-items:center}
.chips{display:flex;gap:6px}
.chip{padding:6px 10px;border-radius:10px;background:#0d1620;border:1px solid #213b53;cursor:pointer;color:var(--muted)}
.chip.active{background:rgba(107,156,255,0.12);border-color:var(--accent);color:#dfeeff}
.playbtn{padding:8px 12px;border-radius:10px;background:#0f1720;border:1px solid #23455f;cursor:pointer}
.playbtn.playing{border-color:var(--ok);color:var(--ok)}
.rollwrap{background:var(--panel);padding:10px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:8px;min-height:0}
.rollArea{position:relative;height:360px;border-radius:8px;overflow:auto;background:#071219;border:1px solid #172735}
canvas{display:block}
.keysCanvas{position:absolute;left:0;top:0;z-index:10;background:rgba(0,0,0,0.03)}
.notesCanvas{position:absolute;left:0;top:0;z-index:20}
.hint{font-size:12px;color:var(--muted)}
.mixer{background:var(--panel);padding:10px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;overflow:auto}
.strip{min-width:160px;background:#0b1419;padding:10px;border-radius:10px;border:1px solid #183248;display:flex;flex-direction:column;gap:8px}
.small{font-size:12px;color:var(--muted)}
.inst-win{position:fixed;width:420px;border-radius:12px;overflow:hidden;background:#071219;border:1px solid #1f3245;box-shadow:0 20px 60px rgba(0,0,0,0.6);z-index:60}
.inst-title{display:flex;align-items:center;justify-content:space-between;padding:10px;background:rgba(255,255,255,0.02);cursor:move}
.inst-bg{height:180px;background:#0b1115;background-size:cover;background-position:center}
.inst-ctrls{display:flex;gap:8px;padding:10px;flex-wrap:wrap}
.knob{flex:1 1 120px;background:#0c1620;padding:8px;border-radius:8px;border:1px solid #162b3f}
.knob label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
.kbdhint{padding:8px;font-size:12px;color:var(--muted)}
.right-actions{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>

<header>
  <div class="brand">CAJA DE RITMOS - MINI DAW</div>
  <div class="buttons">
    <button id="playBtn" class="btn playbtn">▶ Play</button>
    <button id="loopBtn" class="btn">Loop: OFF</button>
    <button id="clearBtn" class="btn">Limpiar</button>
  </div>
</header>

<div class="main">
  <!-- LEFT: rows (cada fila = sample) -->
  <aside class="left" id="left">
    <h3>Instrumentos (cada fila es un sample)</h3>
    <!-- botones dinámicos generados por JS -->
    <div id="rowsList"></div>
    <div style="margin-top:10px" class="small">Haz click en una fila para abrir su ventana y luego crea su canal en el mixer.</div>
  </aside>

  <!-- CENTER: roll + mixer -->
  <section class="center">
    <div class="controls">
      <div class="chips" id="gridChips"></div>
      <div class="small" style="margin-left:12px">Tempo <input id="tempo" type="number" value="100" min="40" max="220" style="width:80px;margin-left:6px"></div>
      <div class="small" style="margin-left:12px">Compases <input id="bars" type="number" value="4" min="1" max="64" style="width:60px;margin-left:6px"></div>
      <div class="small" style="margin-left:12px">Zoom <input id="zoom" type="range" min="40" max="180" value="80"></div>
      <div style="margin-left:auto" class="small">Click: crear · Arrastrar: mover/estirar · Click derecho: borrar</div>
    </div>

    <div class="rollwrap">
      <div class="rollArea" id="rollArea">
        <canvas id="keysCanvas" class="keysCanvas"></canvas>
        <canvas id="notesCanvas" class="notesCanvas"></canvas>
      </div>
      <div class="hint">Cada fila es un sample/percussion. Abre la ventana de fila para crear canal y grabar su salida.</div>
    </div>

    <div class="mixer" id="mixer"></div>
  </section>
</div>

<!-- single floating instrument window created by JS -->
<script>
/* ========================= CONFIG y SAMPLES FICTICIOS ========================= */
const sampleRows = [
  {id:1, name:'Conga', wav:'samples/conga.wav', img:'imgs/conga.png'},
  {id:2, name:'Guiro', wav:'samples/guiro.wav', img:'imgs/guiro.png'},
  {id:3, name:'Timbal', wav:'samples/timbal.wav', img:'imgs/timbal.png'},
  {id:4, name:'Kick', wav:'samples/kick.wav', img:'imgs/kick.png'},
  {id:5, name:'Snare', wav:'samples/snare.wav', img:'imgs/snare.png'},
  {id:6, name:'HiHat', wav:'samples/hihat.wav', img:'imgs/hihat.png'},
  {id:7, name:'Clap', wav:'samples/clap.wav', img:'imgs/clap.png'},
  {id:8, name:'Cowbell', wav:'samples/cowbell.wav', img:'imgs/cowbell.png'},
  {id:9, name:'Shaker', wav:'samples/shaker.wav', img:'imgs/shaker.png'},
  {id:10, name:'Tom', wav:'samples/tom.wav', img:'imgs/tom.png'}
];
// Puedes ampliar sampleRows con más items; usa rutas que luego reemplazarás por tus WAVs/IMGs

/* ========================= Audio core ========================= */
const audio = {
  ctx: new (window.AudioContext || window.webkitAudioContext)(),
  master: null,
  mediaDest: null,
  recorder: null,
  chunks: [],
  buffers: {},    // rowId -> AudioBuffer
  mixer: {},      // rowId -> {gainNode, panNode, el, recorder, mediaDest}
  liveHandles: new Set(),
  init(){
    this.master = this.ctx.createGain(); this.master.gain.value = 1;
    const pan = this.ctx.createStereoPanner();
    this.master.connect(pan).connect(this.ctx.destination);
    // for master recording if needed
    this.mediaDest = this.ctx.createMediaStreamDestination();
    this.master.connect(this.mediaDest);
  },
  async loadBuffer(rowId){
    if (this.buffers[rowId]) return;
    const row = sampleRows.find(r=>r.id===rowId);
    if (!row) return;
    try {
      const res = await fetch(row.wav);
      if (!res.ok) throw new Error('HTTP '+res.status);
      const ab = await res.arrayBuffer();
      this.buffers[rowId] = await this.ctx.decodeAudioData(ab);
      console.log('Loaded', row.wav);
    } catch(err){
      console.warn('No se pudo cargar', row.wav, err);
    }
  },
  noteOn({rowId, when=0}){
    const buf = this.buffers[rowId];
    if (!buf) return null;
    const ctx = this.ctx;
    const src = ctx.createBufferSource(); src.buffer = buf;
    const amp = ctx.createGain(); amp.gain.value = 1;
    const filt = ctx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value = 12000;

    // route to per-channel gain if exists otherwise to master
    const dest = this.mixer[rowId]?.gainNode || this.master;
    src.connect(filt).connect(amp).connect(dest);

    // ensure it stops itself and clean references
    src.onended = ()=> {
      try{ src.disconnect(); } catch(_) {}
      try{ filt.disconnect(); } catch(_) {}
      try{ amp.disconnect(); } catch(_) {}
      this.liveHandles.delete(handle);
    };

    const t0 = ctx.currentTime + when;
    src.start(t0);
    const handle = {source:src, amp, start:t0};
    this.liveHandles.add(handle);
    return handle;
  },
  noteOff(handle){
    if (!handle) return;
    try{
      const now = this.ctx.currentTime;
      handle.source.stop(now+0.02);
      this.liveHandles.delete(handle);
    }catch(e){}
  },
  panicAll(){
    for (const h of Array.from(this.liveHandles)) try{ h.source.stop(); }catch(_){}
    this.liveHandles.clear();
  }
};
audio.init();

/* ========================= UI: filas (left) ========================= */
const rowsList = document.getElementById('rowsList');
sampleRows.forEach(row=>{
  const btn = document.createElement('div');
  btn.className = 'row-btn';
  btn.innerHTML = `<div>${row.name}</div><div class="small">ID ${row.id}</div>`;
  btn.onclick = ()=> openRowWindow(row.id);
  rowsList.appendChild(btn);
});

/* ========================= Piano-roll grid + canvases ========================= */
const notesCanvas = document.getElementById('notesCanvas');
const keysCanvas  = document.getElementById('keysCanvas');
const rollArea = document.getElementById('rollArea');

const roll = {
  rows: sampleRows.length,
  rowH: 34,
  keyLaneW: 140,
  bars: 4,
  tempo: 100,
  pxPerBeat: 80,
  quant: 1/4,
  notes: [], // {x(len in beats start), len, rowId}
  dragging: null,
  playing: false,
  loop: false,
  startMs: 0,
  scheduledTimeout: null,
  scheduledHandles: []
};

function resizeCanvas(){
  const beats = roll.bars*4;
  const w = roll.keyLaneW + Math.max(600, Math.ceil(roll.pxPerBeat*beats));
  const h = roll.rows * roll.rowH;
  notesCanvas.width = w; notesCanvas.height = h;
  keysCanvas.width = roll.keyLaneW; keysCanvas.height = h;
  notesCanvas.style.left = '0px'; notesCanvas.style.top = '0px';
  keysCanvas.style.left = '0px'; keysCanvas.style.top = '0px';
  rollArea.scrollLeft = 0;
  drawAll();
}
resizeCanvas();

function beatsToPx(b){ return b * roll.pxPerBeat; }
function pxToBeats(px){ return px / roll.pxPerBeat; }
function quantize(b){ const q = roll.quant; return Math.round(b/q)*q; }

function drawKeys(){
  const kctx = keysCanvas.getContext('2d');
  kctx.clearRect(0,0,keysCanvas.width,keysCanvas.height);
  for (let i=0;i<roll.rows;i++){
    const y = i*roll.rowH;
    kctx.fillStyle = (i%2===0)?'#07121a':'#07151c';
    kctx.fillRect(0,y,keysCanvas.width,roll.rowH);
    kctx.strokeStyle='#0e2432';
    kctx.beginPath(); kctx.moveTo(0,y+0.5); kctx.lineTo(keysCanvas.width,y+0.5); kctx.stroke();
    const row = sampleRows[i];
    kctx.fillStyle='#dfeeff';
    kctx.font='13px sans-serif';
    kctx.fillText(row.name, 10, y + 20);
    kctx.fillStyle='#98b9d2';
    kctx.font='11px sans-serif';
    kctx.fillText('ID '+row.id, 10, y + 32);
  }
}

function drawNotes(){
  const ctx = notesCanvas.getContext('2d');
  ctx.clearRect(0,0,notesCanvas.width,notesCanvas.height);

  // vertical grid
  const beats = roll.bars*4;
  for (let b=0;b<=beats;b+=roll.quant){
    const x = roll.keyLaneW + beatsToPx(b);
    ctx.strokeStyle = (Math.abs(b-Math.round(b))<1e-6)?'#183044':'#0f2a3b';
    ctx.lineWidth = (Math.abs(b-Math.round(b))<1e-6)?1.2:1;
    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,notesCanvas.height); ctx.stroke();
  }

  // notes
  for (const n of roll.notes){
    const rowIdx = sampleRows.findIndex(r=>r.id===n.rowId);
    if (rowIdx < 0) continue;
    const y = rowIdx * roll.rowH + 6;
    const x = roll.keyLaneW + beatsToPx(n.x);
    const w = Math.max(6, Math.floor(beatsToPx(n.len)));
    const h = roll.rowH - 12;
    const hue = (n.rowId * 78) % 360;
    ctx.fillStyle = `hsl(${hue} 70% 55% / 0.95)`;
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = `hsl(${hue} 80% 35%)`;
    ctx.strokeRect(x+0.5, y+0.5, w, h);
    // resize handle
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(x + w - 6, y, 6, h);
  }

  // playhead
  if (roll.playing){
    const elapsed = (performance.now() - roll.startMs);
    const playbeat = (elapsed / 1000) / (60/roll.tempo);
    const x = roll.keyLaneW + beatsToPx(playbeat % (roll.bars*4));
    ctx.strokeStyle = '#ff4d4f'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,notesCanvas.height); ctx.stroke();
    requestAnimationFrame(drawNotes);
  }
}

function drawAll(){ drawKeys(); drawNotes(); }
drawAll();

/* hit test */
function hitNoteAt(mx,my){
  for (let i=roll.notes.length-1;i>=0;i--){
    const n = roll.notes[i];
    const rowIdx = sampleRows.findIndex(r=>r.id===n.rowId);
    if (rowIdx<0) continue;
    const x = roll.keyLaneW + beatsToPx(n.x);
    const w = beatsToPx(n.len);
    const y = rowIdx * roll.rowH + 6;
    const h = roll.rowH - 12;
    if (mx>=x && mx<=x+w && my>=y && my<=y+h){
      return {note:n, index:i, x,y,w,h};
    }
  }
  return null;
}

/* mouse events */
notesCanvas.addEventListener('mousedown', async (e)=>{
  if (e.button===2) return; // handled separately
  const rect = notesCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const b = pxToBeats(Math.max(0, mx - roll.keyLaneW));
  const row = Math.floor(my / roll.rowH);
  const hit = hitNoteAt(mx,my);
  if (hit){
    // move or resize
    const nearRight = (mx >= hit.x + hit.w - 6);
    if (nearRight){
      roll.dragging = {type:'resize', note:hit.note, index:hit.index};
    } else {
      roll.dragging = {type:'move', note:hit.note, index:hit.index, offBeat: b - hit.note.x, offRow: row - sampleRows.findIndex(r=>r.id===hit.note.rowId)};
    }
    return;
  }
  // create new note on that row
  const rowId = sampleRows[row].id;
  const xBeat = quantize(b);
  const newNote = {x:xBeat, len: roll.quant, rowId};
  roll.notes.push(newNote);
  roll.dragging = {type:'resize', note:newNote, index: roll.notes.length-1};
  await audio.loadBuffer(rowId); // pre-load
  // create mixer channel automatically? no — user must create channel in window; we only ensure buffer
  drawAll();
});

notesCanvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const rect = notesCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
  const hit = hitNoteAt(mx,my);
  if (hit) {
    roll.notes.splice(hit.index,1);
    drawAll();
    // maybe remove mixer if now unused
    maybeRemoveMixer(hit.note.rowId);
  }
});

window.addEventListener('mousemove', (e)=>{
  if (!roll.dragging) return;
  const rect = notesCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const b = pxToBeats(Math.max(0, mx - roll.keyLaneW));
  const rowIdx = Math.floor(my/roll.rowH);
  const r = Math.max(0, Math.min(roll.rows-1, rowIdx));
  const n = roll.dragging.note;
  if (roll.dragging.type === 'move'){
    n.x = Math.max(0, quantize(b - roll.dragging.offBeat));
    n.rowId = sampleRows[Math.max(0,Math.min(roll.rows-1, r - roll.dragging.offRow))].id;
  } else {
    n.len = Math.max(roll.quant, quantize(b - n.x));
  }
  drawAll();
});

window.addEventListener('mouseup', ()=>{
  roll.dragging = null;
});

/* grid chips */
const gridList = [1,0.5,0.25,0.125,0.0625,0.03125];
const gridChips = document.getElementById('gridChips');
gridList.forEach(g=>{
  const el = document.createElement('div'); el.className='chip' + (g===roll.quant?' active':'');
  el.textContent = (g===1)?'1/1':(g===0.5)?'1/2':'1/'+(1/g);
  el.onclick = ()=> { roll.quant=g; [...gridChips.children].forEach(c=>c.classList.remove('active')); el.classList.add('active'); drawAll(); };
  gridChips.appendChild(el);
});

/* tempo / bars / zoom */
document.getElementById('tempo').addEventListener('input', (e)=> roll.tempo = Math.max(40, Math.min(220, +e.target.value||100)));
document.getElementById('bars').addEventListener('input', (e)=> { roll.bars = Math.max(1, Math.min(64, +e.target.value||4)); resizeCanvas(); });
document.getElementById('zoom').addEventListener('input', (e)=> { roll.pxPerBeat = +e.target.value; resizeCanvas(); });

/* ========================= Playback scheduling with loop ========================= */
let scheduleTimer = null;
function scheduleLoop(startTime){
  // schedule all notes for one loop iteration starting at startTime (AudioContext time)
  const spb = 60/roll.tempo;
  const loopLenBeats = roll.bars * 4;
  const loopLenSec = loopLenBeats * spb;
  const now = audio.ctx.currentTime;
  // schedule notes
  for (const n of roll.notes){
    const when = startTime + (n.x * spb); // seconds absolute
    // create a source at that time
    const handle = audio.noteOn({rowId:n.rowId, when: (when - now)});
    if (handle) {
      // schedule stop automatically by buffer length or leave it (buffer ends)
      // keep handle to stop later if needed
      audio.scheduledHandles = audio.scheduledHandles || [];
      audio.scheduledHandles.push(handle);
    }
  }
  // schedule next iteration if loop is enabled
  if (roll.loop){
    const msUntilNext = Math.max(0, (startTime + loopLenSec - audio.ctx.currentTime) * 1000 - 60);
    roll.scheduledTimeout = setTimeout(()=>{
      scheduleLoop(startTime + loopLenSec);
    }, msUntilNext);
  } else {
    // not loop: set a timeout to stop playing after loopLenSec
    roll.scheduledTimeout = setTimeout(()=> stopPlay(), (loopLenSec*1000)+200);
  }
}

function startPlay(){
  if (audio.ctx.state==='suspended') audio.ctx.resume();
  // preload buffers for used rows
  const usedRows = [...new Set(roll.notes.map(n=>n.rowId))];
  Promise.all(usedRows.map(id=>audio.loadBuffer(id))).then(()=>{
    roll.playing = true; roll.startMs = performance.now();
    document.getElementById('playBtn').classList.add('playing'); document.getElementById('playBtn').textContent='⏹ Stop';
    // schedule starting immediately
    scheduleLoop(audio.ctx.currentTime + 0.02);
  });
}

function stopPlay(){
  roll.playing = false;
  // cancel scheduled timeouts and stop scheduled handles
  if (roll.scheduledTimeout) { clearTimeout(roll.scheduledTimeout); roll.scheduledTimeout = null; }
  if (audio.scheduledHandles){
    for (const h of audio.scheduledHandles){ try{ audio.noteOff(h); }catch(_){} }
    audio.scheduledHandles = [];
  }
  audio.panicAll();
  document.getElementById('playBtn').classList.remove('playing'); document.getElementById('playBtn').textContent='▶ Play';
  drawAll();
}

/* play button / loop toggle / clear */
document.getElementById('playBtn').onclick = ()=>{ if (roll.playing) stopPlay(); else startPlay(); };
document.getElementById('loopBtn').onclick = (e)=>{ roll.loop = !roll.loop; e.target.textContent = 'Loop: ' + (roll.loop? 'ON':'OFF'); };
document.getElementById('clearBtn').onclick = ()=>{ roll.notes=[]; drawAll(); /* maybe remove all unused mixers */ for (const r of sampleRows) maybeRemoveMixer(r.id); };

/* ========================= Instrument window (single) and Create Channel ========================= */
let currentWin = null;
function openRowWindow(rowId){
  const row = sampleRows.find(r=>r.id===rowId); if(!row) return;
  // ensure single window
  if (currentWin) currentWin.remove();
  const win = document.createElement('div'); win.className='inst-win'; win.style.left='100px'; win.style.top='80px';
  win.innerHTML = `
    <div class="inst-title"><div style="font-weight:700">${row.name}</div><div style="display:flex;gap:8px">
      <button class="btn" id="createChannel">Crear Canal</button>
      <div class="btn" id="closeWin">✕</div>
    </div></div>
    <div class="inst-bg" style="background-image:url('${row.img || ''}');"></div>
    <div class="inst-ctrls">
      <div class="knob"><label>Gain</label><input type="range" min="0" max="2" step="0.01" value="1" data-k="gain"></div>
      <div class="knob"><label>Cutoff</label><input type="range" min="100" max="12000" step="1" value="12000" data-k="cutoff"></div>
      <div class="knob"><label>Attack (ms)</label><input type="range" min="0" max="500" step="1" value="10" data-k="attack"></div>
      <div class="knob"><label>Release (ms)</label><input type="range" min="0" max="2000" step="1" value="100" data-k="release"></div>
    </div>
    <div class="kbdhint">Ventana del sample: Crear Canal para añadir strip en Mixer. Puedes moverla arrastrando la barra.</div>
  `;
  document.body.appendChild(win);
  currentWin = win;

  // drag
  const header = win.querySelector('.inst-title');
  let dragging=false, ox=0, oy=0;
  header.addEventListener('mousedown', (e)=>{ dragging=true; ox=e.clientX-win.offsetLeft; oy=e.clientY-win.offsetTop; document.body.style.userSelect='none'; });
  document.addEventListener('mousemove', (e)=>{ if(!dragging) return; win.style.left = (e.clientX-ox)+'px'; win.style.top = (e.clientY-oy)+'px'; });
  document.addEventListener('mouseup', ()=>{ dragging=false; document.body.style.userSelect=''; });

  win.querySelector('#closeWin').onclick = ()=>{ win.remove(); currentWin=null; };

  // Create Channel button
  win.querySelector('#createChannel').onclick = async ()=>{
    // create mixer strip for rowId if not exists
    if (audio.mixer[rowId]) return alert('Canal ya creado para este sample');
    await audio.loadBuffer(rowId).catch(()=>{});
    createMixerStripForRow(rowId);
  };
}

/* ========================= Mixer: crear strip por rowId + grabar canal ========================= */
const mixerEl = document.getElementById('mixer');
function createMixerStripForRow(rowId){
  const row = sampleRows.find(r=>r.id===rowId);
  if (!row) return;
  const inst = row;
  const strip = document.createElement('div'); strip.className='strip';
  strip.innerHTML = `
    <h4>${inst.name}</h4>
    <div class="small">Volumen</div>
    <input class="fader" type="range" min="0" max="2" step="0.01" value="1" data-vol>
    <div class="small">Pan</div>
    <input class="fader" type="range" min="-1" max="1" step="0.01" value="0" data-pan>
    <div style="display:flex;gap:8px;align-items:center">
      <button class="btn" data-rec>Grabar</button>
      <button class="btn" data-del>Eliminar</button>
    </div>
    <div class="small">Nivel</div>
    <div class="meter" id="meter-${rowId}"></div>
  `;
  mixerEl.appendChild(strip);

  // audio nodes
  const gainNode = audio.ctx.createGain(); gainNode.gain.value = 1;
  const panNode = audio.ctx.createStereoPanner(); panNode.pan.value = 0;
  gainNode.connect(panNode).connect(audio.master);

  audio.mixer[rowId] = {gainNode, panNode, el:strip, recorder:null, mediaDest:null};

  // controls
  strip.querySelector('[data-vol]').addEventListener('input', (e)=>{ gainNode.gain.value = +e.target.value; });
  strip.querySelector('[data-pan]').addEventListener('input', (e)=>{ panNode.pan.value = +e.target.value; });

  // record button
  const recBtn = strip.querySelector('[data-rec]');
  let recInstance = null;
  recBtn.onclick = async ()=>{
    if (!recInstance){
      // start recording this channel by creating a MediaStreamDestination and MediaRecorder
      const md = audio.ctx.createMediaStreamDestination();
      // connect channel output to this md as well (duplicate connection)
      audio.mixer[rowId].gainNode.connect(md);
      const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
      const recorder = new MediaRecorder(md.stream, {mimeType:mime});
      const chunks = [];
      recorder.ondataavailable = e=>chunks.push(e.data);
      recorder.onstop = ()=> {
        const blob = new Blob(chunks, {type: recorder.mimeType});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = `${inst.name.replace(/\s+/g,'_')}_channel.webm`; a.click();
        URL.revokeObjectURL(url);
      };
      recorder.start();
      recBtn.textContent = '■ Grabando';
      recBtn.style.background = 'linear-gradient(180deg,#330000,#661111)';
      recInstance = {recorder, md};
      audio.mixer[rowId].recorder = recInstance;
    } else {
      // stop
      try{ recInstance.recorder.stop(); }catch(_){}
      try{ recInstance.md.disconnect(); }catch(_){}
      recInstance = null;
      audio.mixer[rowId].recorder = null;
      recBtn.textContent = 'Grabar';
      recBtn.style.background = '';
    }
  };

  // delete channel
  strip.querySelector('[data-del]').onclick = ()=>{
    // stop recorder if active
    const m = audio.mixer[rowId];
    if (m && m.recorder){
      try{ m.recorder.recorder.stop(); }catch(_){}
      try{ m.recorder.md.disconnect(); }catch(_){}
    }
    // disconnect nodes
    try{ gainNode.disconnect(); }catch(_){}
    try{ panNode.disconnect(); }catch(_){}
    strip.remove();
    delete audio.mixer[rowId];
  };
}

/* remove mixer if unused */
function maybeRemoveMixer(rowId){
  const used = roll.notes.some(n=>n.rowId===rowId);
  if (!used && audio.mixer[rowId]){
    // remove strip similar to delete button
    const m = audio.mixer[rowId];
    try{ m.el.remove(); }catch(_){}
    try{ m.gainNode.disconnect(); }catch(_){}
    try{ m.panNode.disconnect(); }catch(_){}
    if (m.recorder){ try{ m.recorder.recorder.stop(); }catch(_){ } }
    delete audio.mixer[rowId];
  }
}

/* ========================= small helpers ========================= */
// prevent text selection during drag on canvases
['mousedown','mousemove','mouseup'].forEach(ev=>{
  window.addEventListener(ev, (e)=>{ if (e.target===notesCanvas || e.target===keysCanvas) e.preventDefault(); }, {passive:false});
});

// handle resize on window
window.addEventListener('resize', ()=>{ resizeCanvas(); drawAll(); });

</script>
</body>
</html>
