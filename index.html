<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>Mini DAW — Melódicos + Caja de Ritmos + Mixer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --bg:#071018; --panel:#0f1820; --accent:#6b9cff; --text:#e8eef5; --muted:#9fb4c8;
  --ok:#2ecc71; --danger:#ff5a5f; --radius:12px; --line:#18324a;
}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:linear-gradient(180deg,#071018,#08121a);color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial;display:flex;flex-direction:column}
header{display:flex;align-items:center;gap:10px;padding:10px 14px;background:rgba(255,255,255,0.02);border-bottom:1px solid rgba(255,255,255,0.06);position:sticky;top:0;z-index:5}
.brand{font-weight:800;letter-spacing:.5px}
.spacer{flex:1}
.btn{padding:8px 12px;border-radius:10px;background:#0c1620;border:1px solid var(--line);color:var(--text);cursor:pointer}
.btn:disabled{opacity:.5;cursor:not-allowed}
.btn.primary{background:#0f1720;border-color:#23455f}
.btn.rec{background:linear-gradient(180deg,#330000,#661111)}
.badge{font-size:12px;color:var(--muted)}
input[type="range"]{width:100%}

.main{flex:1;display:grid;grid-template-columns:320px 1fr;gap:12px;padding:12px;min-height:0}
.left{background:var(--panel);padding:12px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.05);overflow:auto}
.left h3{margin:0 0 8px 0;color:var(--muted);font-size:13px}
.section{margin-bottom:14px}
.row-btn{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:10px;background:#08121a;border:1px dashed rgba(255,255,255,0.06);margin-bottom:8px;cursor:pointer}
.row-btn:hover{border-style:solid;border-color:#234a76}
.row-btn .small{font-size:12px;color:var(--muted)}
.kbhelp{font-size:12px;color:var(--muted);padding:8px;background:#08121a;border:1px dashed rgba(255,255,255,0.06);border-radius:10px}

.center{display:flex;flex-direction:column;gap:10px;min-width:0}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.chips{display:flex;gap:6px}
.chip{padding:6px 10px;border-radius:10px;background:#0d1620;border:1px solid #213b53;cursor:pointer;color:var(--muted)}
.chip.active{background:rgba(107,156,255,0.12);border-color:var(--accent);color:#dfeeff}

.panel{background:var(--panel);padding:10px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.05)}
.grid2{display:grid;grid-template-columns:1fr;gap:10px}
@media (min-width:1100px){ .grid2{grid-template-columns:1fr 1fr} }

.rollwrap{display:flex;flex-direction:column;gap:8px;min-height:0}
.rollArea{position:relative;height:360px;border-radius:8px;overflow:auto;background:#071219;border:1px solid #172735}
canvas{display:block}
.keysCanvas{position:absolute;left:0;top:0;z-index:10;background:rgba(0,0,0,0.03)}
.notesCanvas{position:absolute;left:0;top:0;z-index:20}

.mixer{display:flex;gap:10px;overflow:auto}
.strip{min-width:180px;background:#0b1419;padding:10px;border-radius:10px;border:1px solid #183248;display:flex;flex-direction:column;gap:8px}
.strip h4{margin:0}
.row{display:flex;align-items:center;gap:8px}
.small{font-size:12px;color:var(--muted)}
.mute{background:#1e2a33}
.solo{background:#1b2b1b}
.clipbar{display:flex;gap:6px;flex-wrap:wrap}
.clipdot{width:8px;height:8px;border-radius:999px;background:#6b9cff;display:inline-block}

.inst-win{position:fixed;width:440px;border-radius:12px;overflow:hidden;background:#071219;border:1px solid #1f3245;box-shadow:0 20px 60px rgba(0,0,0,0.6);z-index:60}
.inst-title{display:flex;align-items:center;justify-content:space-between;padding:10px;background:rgba(255,255,255,0.02);cursor:move}
.inst-bg{height:180px;background:#0b1115;background-size:cover;background-position:center}
.inst-ctrls{display:flex;gap:8px;padding:10px;flex-wrap:wrap}
.knob{flex:1 1 140px;background:#0c1620;padding:8px;border-radius:8px;border:1px solid #162b3f}
.knob label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}

footer{padding:6px 12px;color:var(--muted);font-size:12px;display:flex;gap:6px;align-items:center}
</style>
</head>
<body>

<header>
  <div class="brand">MINI DAW — Melódicos + Caja de Ritmos + Mixer</div>
  <button id="masterPlay" class="btn primary">▶ Play</button>
  <button id="masterLoop" class="btn">Loop: OFF</button>
  <button id="masterRec" class="btn">Grabar Master</button>
  <span class="badge">Tempo <input id="tempo" type="number" value="100" min="40" max="220" style="width:80px;margin-left:6px"></span>
  <span class="badge">Compases <input id="bars" type="number" value="4" min="1" max="64" style="width:60px;margin-left:6px"></span>
  <span class="badge">Zoom <input id="zoom" type="range" min="40" max="180" value="80" style="width:120px"></span>
  <div class="spacer"></div>
</header>

<div class="main">
  <!-- LEFT -->
  <aside class="left" id="left">
    <h3>Instrumentos melódicos (selecciona y toca en vivo)</h3>
    <div id="melodicList" class="section"></div>
    <div class="kbhelp">
      Teclado: Z X C V B N M , . / (octava ± con [ y ]) — Click también dispara.  
      Abrí la ventana del instrumento para “Crear Canal” en el mixer y grabar su salida.
    </div>

    <h3 style="margin-top:14px">Instrumentos de percusión (WAV por fila del roll)</h3>
    <div id="percList" class="section"></div>
  </aside>

  <!-- CENTER -->
  <section class="center">
    <div class="grid2">
      <div class="panel">
        <div class="controls">
          <div class="chips" id="gridChips"></div>
          <div class="small" style="margin-left:auto">Click: crear · Arrastrar: mover/estirar · Click derecho: borrar</div>
        </div>
        <div class="rollwrap">
          <div class="rollArea" id="rollArea">
            <canvas id="keysCanvas" class="keysCanvas"></canvas>
            <canvas id="notesCanvas" class="notesCanvas"></canvas>
          </div>
          <div class="small">Cada fila = sample de percusión (WAV). Al programar un bloque, se crea/usa su canal en el mixer.</div>
        </div>
      </div>

      <div class="panel">
        <div class="mixer" id="mixer"></div>
      </div>
    </div>
  </section>
</div>

<footer>
  <div>Master Play reproduce caja de ritmos + clips guardados. Grabar Master exporta el mix a .webm (compatible).</div>
</footer>

<script>
/* ==================== DATOS ==================== */
/* Percusión (mismos nombres/rutas/backgrounds que ya venías usando) */
const percRows = [
  {id:1, name:'Conga',   wav:'samples/conga.wav',   img:'imgs/conga.png'},
  {id:2, name:'Guiro',   wav:'samples/guiro.wav',   img:'imgs/guiro.png'},
  {id:3, name:'Timbal',  wav:'samples/timbal.wav',  img:'imgs/timbal.png'},
  {id:4, name:'Kick',    wav:'samples/kick.wav',    img:'imgs/kick.png'},
  {id:5, name:'Snare',   wav:'samples/snare.wav',   img:'imgs/snare.png'},
  {id:6, name:'HiHat',   wav:'samples/hihat.wav',   img:'imgs/hihat.png'},
  {id:7, name:'Clap',    wav:'samples/clap.wav',    img:'imgs/clap.png'},
  {id:8, name:'Cowbell', wav:'samples/cowbell.wav', img:'imgs/cowbell.png'},
  {id:9, name:'Shaker',  wav:'samples/shaker.wav',  img:'imgs/shaker.png'},
  {id:10,name:'Tom',     wav:'samples/tom.wav',     img:'imgs/tom.png'}
];

/* MELÓDICOS — PEGA AQUÍ EXACTAMENTE TU LISTA DEL CÓDIGO 1 (mismos nombres/rutas/backgrounds) */
const melodicInstruments = [
  // EJEMPLOS (elimínalos si pegas los tuyos):
  {id:'piano',   name:'Piano',    wav:'samples/piano.wav',   img:'imgs/piano.png'},
  {id:'rhodes',  name:'Rhodes',   wav:'samples/rhodes.wav',  img:'imgs/rhodes.png'},
  {id:'bass',    name:'Bass',     wav:'samples/bass.wav',    img:'imgs/bass.png'},
  {id:'sawlead', name:'Saw Lead', wav:'samples/sawlead.wav', img:'imgs/sawlead.png'},
  {id:'pad',     name:'Pad',      wav:'samples/pad.wav',     img:'imgs/pad.png'}
];

/* ==================== AUDIO CORE ==================== */
const audio = {
  ctx: new (window.AudioContext||window.webkitAudioContext)(),
  master: null,
  masterTap: null,       // MediaStreamDestination para grabación master
  buffers: {},           // id -> AudioBuffer
  mixer: {},             // id -> estado canal
  liveHandles: new Set(),
  init(){
    this.master = this.ctx.createGain(); this.master.gain.value=1;
    const pan = this.ctx.createStereoPanner();
    this.master.connect(pan).connect(this.ctx.destination);

    // Salida a grabador master:
    this.masterTap = this.ctx.createMediaStreamDestination();
    this.master.connect(this.masterTap);
  },
  async loadBuffer(entry){
    const id = entry.id;
    if (this.buffers[id]) return this.buffers[id];
    const res = await fetch(entry.wav);
    if (!res.ok) throw new Error('HTTP '+res.status+' '+entry.wav);
    const ab = await res.arrayBuffer();
    const buf = await this.ctx.decodeAudioData(ab);
    this.buffers[id]=buf; return buf;
  },
  noteOn({id, when=0, playbackRate=1}){
    const buf = this.buffers[id];
    if (!buf) return null;
    const ctx = this.ctx;
    const src = ctx.createBufferSource(); src.buffer=buf; src.playbackRate.value=playbackRate;
    const amp = ctx.createGain(); amp.gain.value=1;
    const dest = this.mixer[id]?.gainNode || this.master;
    src.connect(amp).connect(dest);
    src.onended = ()=>{ try{src.disconnect();amp.disconnect();}catch(_){ } this.liveHandles.delete(h); };
    const t0 = ctx.currentTime + when; src.start(t0);
    const h = {source:src, amp, start:t0, id}; this.liveHandles.add(h);
    return h;
  },
  stopAll(){
    for (const h of Array.from(this.liveHandles)) { try{h.source.stop();}catch(_){} }
    this.liveHandles.clear();
  }
};
audio.init();

/* ==================== UI LISTAS ==================== */
const melodicList = document.getElementById('melodicList');
const percList = document.getElementById('percList');
function makeRowBtn(entry, onClick){
  const div=document.createElement('div'); div.className='row-btn';
  div.innerHTML=`<div>${entry.name}</div><div class="small">${entry.id}</div>`;
  div.onclick=()=>onClick(entry);
  return div;
}
melodicInstruments.forEach(inst=> melodicList.appendChild(makeRowBtn(inst, openInstrumentWindow)));
percRows.forEach(dr=> percList.appendChild(makeRowBtn(dr, ()=> openPercWindow(dr))));

/* ==================== TECLADO EN VIVO (melódicos) ==================== */
const keyMap = 'zsxdcvgbhnjm,l.;/'.split('');
let baseTranspose = 0; // semitonos
window.addEventListener('keydown', async (e)=>{
  if (e.repeat) return;
  if (e.key==='['){ baseTranspose=Math.max(-24,baseTranspose-12); return; }
  if (e.key===']'){ baseTranspose=Math.min( 24,baseTranspose+12); return; }
  const k = e.key.toLowerCase();
  const idx = keyMap.indexOf(k);
  if (idx>=0 && currentMelodicWin?.entry){
    const id = currentMelodicWin.entry.id;
    await audio.loadBuffer(currentMelodicWin.entry);
    const rate = Math.pow(2,(idx+baseTranspose)/12);
    audio.noteOn({id, when:0, playbackRate:rate});
    ensureMixerChannel(id, currentMelodicWin.entry.name);
  }
});

/* ==================== CAJA DE RITMOS ==================== */
const notesCanvas = document.getElementById('notesCanvas');
const keysCanvas  = document.getElementById('keysCanvas');
const rollArea = document.getElementById('rollArea');

const roll = {
  rows: percRows.length, rowH:34, keyLaneW:160,
  bars:4, tempo:100, pxPerBeat:80, quant:1/4,
  notes: [] // {x,len,rowId}
};
function beatsToPx(b){ return b*roll.pxPerBeat; }
function pxToBeats(px){ return px/roll.pxPerBeat; }
function quantize(b){ const q=roll.quant; return Math.round(b/q)*q; }

function resizeCanvas(){
  const beats = roll.bars*4;
  const w = roll.keyLaneW + Math.max(700, Math.ceil(roll.pxPerBeat*beats));
  const h = roll.rows*roll.rowH;
  notesCanvas.width=w; notesCanvas.height=h;
  keysCanvas.width=roll.keyLaneW; keysCanvas.height=h;
  drawAll();
}
function drawKeys(){
  const k=keysCanvas.getContext('2d'); k.clearRect(0,0,keysCanvas.width,keysCanvas.height);
  for (let i=0;i<roll.rows;i++){
    const y=i*roll.rowH;
    k.fillStyle=(i%2===0)?'#07121a':'#07151c';
    k.fillRect(0,y,keysCanvas.width,roll.rowH);
    k.strokeStyle='#0e2432'; k.beginPath(); k.moveTo(0,y+0.5); k.lineTo(keysCanvas.width,y+0.5); k.stroke();
    const row=percRows[i];
    k.fillStyle='#dfeeff'; k.font='13px sans-serif'; k.fillText(row.name,10,y+20);
    k.fillStyle='#98b9d2'; k.font='11px sans-serif'; k.fillText(row.id,10,y+32);
  }
}
function drawNotes(){
  const ctx=notesCanvas.getContext('2d'); ctx.clearRect(0,0,notesCanvas.width,notesCanvas.height);
  const beats = roll.bars*4;
  for (let b=0;b<=beats;b+=roll.quant){
    const x=roll.keyLaneW+beatsToPx(b);
    ctx.strokeStyle=(Math.abs(b-Math.round(b))<1e-6)?'#183044':'#0f2a3b';
    ctx.lineWidth=(Math.abs(b-Math.round(b))<1e-6)?1.2:1;
    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,notesCanvas.height); ctx.stroke();
  }
  for (const n of roll.notes){
    const idx=percRows.findIndex(r=>r.id===n.rowId); if (idx<0) continue;
    const y=idx*roll.rowH+6, x=roll.keyLaneW+beatsToPx(n.x), w=Math.max(6, Math.floor(beatsToPx(n.len))), h=roll.rowH-12;
    const hue=(n.rowId*78)%360;
    ctx.fillStyle=`hsl(${hue} 70% 55% / .95)`; ctx.fillRect(x,y,w,h);
    ctx.strokeStyle=`hsl(${hue} 80% 35%)`; ctx.strokeRect(x+0.5,y+0.5,w,h);
    ctx.fillStyle='#fff'; ctx.fillRect(x+w-6,y,6,h);
  }
  if (transport.playing){
    const elapsed=(performance.now()-transport.startMs);
    const playbeat=(elapsed/1000)/(60/roll.tempo);
    const x=roll.keyLaneW+beatsToPx(playbeat%(roll.bars*4));
    ctx.strokeStyle='#ff4d4f'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,notesCanvas.height); ctx.stroke();
    requestAnimationFrame(drawNotes);
  }
}
function drawAll(){ drawKeys(); drawNotes(); }
resizeCanvas();

function hitNoteAt(mx,my){
  for (let i=roll.notes.length-1;i>=0;i--){
    const n=roll.notes[i]; const rowIdx=percRows.findIndex(r=>r.id===n.rowId); if (rowIdx<0) continue;
    const x=roll.keyLaneW+beatsToPx(n.x), w=beatsToPx(n.len), y=rowIdx*roll.rowH+6, h=roll.rowH-12;
    if (mx>=x && mx<=x+w && my>=y && my<=y+h) return {note:n,index:i,x,y,w,h};
  } return null;
}
let dragging=null;
notesCanvas.addEventListener('mousedown', async (e)=>{
  if (e.button===2) return;
  const r=notesCanvas.getBoundingClientRect(), mx=e.clientX-r.left, my=e.clientY-r.top;
  const b=pxToBeats(Math.max(0, mx-roll.keyLaneW));
  const row=Math.floor(my/roll.rowH);
  const hit=hitNoteAt(mx,my);
  if (hit){
    const nearRight=(mx>=hit.x+hit.w-6);
    dragging = nearRight ? {type:'resize', note:hit.note, index:hit.index}
                         : {type:'move',   note:hit.note, index:hit.index, offBeat:b-hit.note.x, offRow: row - percRows.findIndex(r=>r.id===hit.note.rowId)};
    return;
  }
  const rowId = percRows[Math.max(0,Math.min(roll.rows-1,row))].id;
  const xBeat = quantize(b);
  const newNote = {x:xBeat, len: roll.quant, rowId};
  roll.notes.push(newNote); dragging={type:'resize', note:newNote, index:roll.notes.length-1};
  const entry = percRows.find(r=>r.id===rowId); await audio.loadBuffer(entry);
  ensureMixerChannel(rowId, entry.name, {patternLinked:true});
  drawAll();
});
notesCanvas.addEventListener('contextmenu',(e)=>{
  e.preventDefault();
  const r=notesCanvas.getBoundingClientRect(), mx=e.clientX-r.left, my=e.clientY-r.top;
  const hit=hitNoteAt(mx,my);
  if (hit){ roll.notes.splice(hit.index,1); drawAll(); maybeRemoveMixerIfUnused(hit.note.rowId); }
});
window.addEventListener('mousemove',(e)=>{
  if (!dragging) return;
  const r=notesCanvas.getBoundingClientRect(), mx=e.clientX-r.left, my=e.clientY-r.top;
  const b=pxToBeats(Math.max(0, mx-roll.keyLaneW));
  const rowIdx=Math.floor(my/roll.rowH);
  const n=dragging.note;
  if (dragging.type==='move'){
    n.x=Math.max(0, quantize(b-dragging.offBeat));
    n.rowId=percRows[Math.max(0,Math.min(roll.rows-1, rowIdx - dragging.offRow))].id;
  }else{
    n.len=Math.max(roll.quant, quantize(b-n.x));
  }
  drawAll();
});
window.addEventListener('mouseup', ()=> dragging=null);
['mousedown','mousemove','mouseup'].forEach(ev=>{
  window.addEventListener(ev, (e)=>{ if (e.target===notesCanvas || e.target===keysCanvas) e.preventDefault(); }, {passive:false});
});
window.addEventListener('resize', ()=>{ resizeCanvas(); drawAll(); });

/* Grid chips */
const gridList=[1,0.5,0.25,0.125,0.0625,0.03125];
const gridChips=document.getElementById('gridChips');
gridList.forEach(g=>{
  const el=document.createElement('div'); el.className='chip'+(g===roll.quant?' active':'');
  el.textContent=(g===1)?'1/1':(g===0.5)?'1/2':'1/'+(1/g);
  el.onclick=()=>{ roll.quant=g; [...gridChips.children].forEach(c=>c.classList.remove('active')); el.classList.add('active'); drawAll(); };
  gridChips.appendChild(el);
});

/* ==================== MIXER ==================== */
const mixerEl=document.getElementById('mixer');
function ensureMixerChannel(id, name, opts={}){
  if (audio.mixer[id]){ if (opts.patternLinked) audio.mixer[id].patternLinked=true; return audio.mixer[id]; }

  const strip=document.createElement('div'); strip.className='strip';
  strip.innerHTML=`
    <h4>${name}</h4>
    <div class="row"><span class="small">Volumen</span></div>
    <input type="range" min="0" max="2" step="0.01" value="1" data-vol>
    <div class="row"><span class="small">Pan</span></div>
    <input type="range" min="-1" max="1" step="0.01" value="0" data-pan>
    <div class="row">
      <button class="btn mute" data-mute>M</button>
      <button class="btn solo" data-solo>S</button>
      <button class="btn" data-rec>Grabar</button>
      <button class="btn" data-playclip>▶ Clip</button>
      <button class="btn" data-pat>Patrón</button>
    </div>
    <div class="small">Clips guardados:</div>
    <div class="clipbar" data-clipbar></div>
    <button class="btn" data-del>Eliminar Canal</button>
  `;
  mixerEl.appendChild(strip);

  const gainNode=audio.ctx.createGain(); gainNode.gain.value=1;
  const panNode=audio.ctx.createStereoPanner(); panNode.pan.value=0;
  gainNode.connect(panNode).connect(audio.master);

  const state={
    id, name, el:strip, gainNode, panNode,
    muted:false, solo:false,
    recorder:null, md:null, chunks:[], clipBuffers:[],
    patternLinked: !!opts.patternLinked
  };
  audio.mixer[id]=state;

  strip.querySelector('[data-vol]').addEventListener('input',e=>{ gainNode.gain.value=+e.target.value; });
  strip.querySelector('[data-pan]').addEventListener('input',e=>{ panNode.pan.value=+e.target.value; });

  strip.querySelector('[data-mute]').onclick=()=>{ state.muted=!state.muted; updateMS(); };
  strip.querySelector('[data-solo]').onclick=()=>{ state.solo=!state.solo; updateMS(); };
  function updateMS(){
    const anySolo = Object.values(audio.mixer).some(m=>m.solo);
    for (const m of Object.values(audio.mixer)){
      const vol = +m.el.querySelector('[data-vol]').value;
      const active = anySolo ? m.solo : !m.muted;
      m.gainNode.gain.setTargetAtTime(active?vol:0, audio.ctx.currentTime, 0.01);
    }
  }

  // Grabar clip (se guarda en memoria, no descarga)
  const recBtn=strip.querySelector('[data-rec]');
  recBtn.onclick=()=>{
    if (!state.recorder){
      const md = audio.ctx.createMediaStreamDestination();
      state.gainNode.connect(md);
      const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
      const rec = new MediaRecorder(md.stream,{mimeType:mime});
      state.chunks=[];
      rec.ondataavailable = e=> state.chunks.push(e.data);
      rec.onstop = async ()=>{
        const blob = new Blob(state.chunks,{type:rec.mimeType});
        try{
          const ab = await blob.arrayBuffer();
          const buf = await audio.ctx.decodeAudioData(ab);
          state.clipBuffers.push({type:'buffer', buffer:buf});
        }catch{
          const url = URL.createObjectURL(blob);
          state.clipBuffers.push({type:'media', url});
        }
        renderClipDots(state);
      };
      rec.start();
      state.recorder=rec; state.md=md;
      recBtn.textContent='■ Grabando'; recBtn.classList.add('rec');
    }else{
      try{ state.recorder.stop(); }catch(_){}
      try{ state.md.disconnect(); }catch(_){}
      state.recorder=null; state.md=null;
      recBtn.textContent='Grabar'; recBtn.classList.remove('rec');
    }
  };

  strip.querySelector('[data-playclip]').onclick=()=>{
    const last=state.clipBuffers.at(-1); if (!last) return;
    if (last.type==='buffer'){
      const src=audio.ctx.createBufferSource(); src.buffer=last.buffer; src.connect(state.gainNode); src.start();
    }else{
      const el=new Audio(last.url); const node=audio.ctx.createMediaElementSource(el); node.connect(state.gainNode); el.play();
    }
  };

  strip.querySelector('[data-pat]').onclick=async ()=>{
    if (!state.patternLinked) return;
    const spb=60/roll.tempo, id=state.id;
    const entry = percRows.find(r=>r.id===id) || melodicInstruments.find(r=>r.id===id);
    await audio.loadBuffer(entry);
    const t0=audio.ctx.currentTime+0.03;
    for (const n of roll.notes.filter(n=>n.rowId===id)){
      const when=t0+n.x*spb; audio.noteOn({id, when:when-audio.ctx.currentTime});
    }
  };

  strip.querySelector('[data-del]').onclick=()=>{
    if (state.recorder){ try{state.recorder.stop();}catch(_){}
      try{state.md.disconnect();}catch(_){}
    }
    try{ gainNode.disconnect(); }catch(_){}
    try{ panNode.disconnect(); }catch(_){}
    strip.remove(); delete audio.mixer[id];
  };

  function renderClipDots(st){
    const bar=strip.querySelector('[data-clipbar]'); bar.innerHTML='';
    st.clipBuffers.forEach((_,i)=>{
      const d=document.createElement('span'); d.className='clipdot'; d.title='Clip '+(i+1);
      d.onclick=()=> strip.querySelector('[data-playclip]').click();
      bar.appendChild(d);
    });
  }
  return state;
}
function maybeRemoveMixerIfUnused(rowId){
  const used = roll.notes.some(n=>n.rowId===rowId);
  if (!used && audio.mixer[rowId] && !(audio.mixer[rowId].clipBuffers?.length)){
    const m=audio.mixer[rowId];
    if (m.recorder){ try{m.recorder.stop();}catch(_){}
      try{m.md.disconnect();}catch(_){}
    }
    try{ m.gainNode.disconnect(); }catch(_){}
    try{ m.panNode.disconnect(); }catch(_){}
    try{ m.el.remove(); }catch(_){}
    delete audio.mixer[rowId];
  }
}

/* ==================== VENTANA DE INSTRUMENTO ==================== */
let currentMelodicWin=null;
function openInstrumentWindow(entry){
  if (currentMelodicWin?.el) currentMelodicWin.el.remove();
  const win=document.createElement('div'); win.className='inst-win'; win.style.left='90px'; win.style.top='90px';
  win.innerHTML=`
    <div class="inst-title"><div style="font-weight:700">${entry.name}</div><div style="display:flex;gap:8px">
      <button class="btn" data-create>Crear Canal</button>
      <button class="btn" data-close>✕</button>
    </div></div>
    <div class="inst-bg" style="background-image:url('${entry.img||''}');"></div>
    <div class="inst-ctrls">
      <div class="knob"><label>Gain</label><input type="range" min="0" max="2" step="0.01" value="1" data-k="gain"></div>
      <div class="knob"><label>Cutoff</label><input type="range" min="500" max="20000" step="1" value="20000" data-k="cutoff"></div>
      <div class="knob"><label>Attack (ms)</label><input type="range" min="0" max="500" step="1" value="5" data-k="attack"></div>
      <div class="knob"><label>Release (ms)</label><input type="range" min="0" max="2000" step="1" value="120" data-k="release"></div>
    </div>
    <div class="kbhelp">Toca con teclado/clic. “Crear Canal” agrega el strip al mixer con grabación.</div>
  `;
  document.body.appendChild(win);
  currentMelodicWin={el:win, entry};

  const header=win.querySelector('.inst-title');
  let dr=false,ox=0,oy=0;
  header.addEventListener('mousedown',(e)=>{dr=true;ox=e.clientX-win.offsetLeft;oy=e.clientY-win.offsetTop;document.body.style.userSelect='none';});
  document.addEventListener('mousemove',(e)=>{ if(!dr)return; win.style.left=(e.clientX-ox)+'px'; win.style.top=(e.clientY-oy)+'px';});
  document.addEventListener('mouseup',()=>{dr=false;document.body.style.userSelect='';});

  win.querySelector('[data-close]').onclick=()=>{ win.remove(); currentMelodicWin=null; };
  win.querySelector('[data-create]').onclick=async ()=>{ await audio.loadBuffer(entry); ensureMixerChannel(entry.id, entry.name); };
}
function openPercWindow(entry){ openInstrumentWindow(entry); audio.loadBuffer(entry); }

/* ==================== TRANSPORTE MASTER ==================== */
const transport={playing:false,startMs:0,loop:false};
document.getElementById('tempo').addEventListener('input',e=> roll.tempo=Math.max(40,Math.min(220,+e.target.value||100)));
document.getElementById('bars').addEventListener('input',e=>{ roll.bars=Math.max(1,Math.min(64,+e.target.value||4)); resizeCanvas(); });
document.getElementById('zoom').addEventListener('input',e=>{ roll.pxPerBeat=+e.target.value; resizeCanvas(); });

const btnPlay=document.getElementById('masterPlay');
const btnLoop=document.getElementById('masterLoop');
const btnRec=document.getElementById('masterRec');

btnLoop.onclick=()=>{ transport.loop=!transport.loop; btnLoop.textContent='Loop: '+(transport.loop?'ON':'OFF'); };
btnPlay.onclick=()=>{ if (transport.playing) stopMaster(); else startMaster(); };

function schedulePatternOnce(startTimeSec){
  const spb = 60/roll.tempo;
  // Percusión
  for (const n of roll.notes){
    const id=n.rowId; const entry=percRows.find(r=>r.id===id); if (!entry) continue;
    audio.loadBuffer(entry).then(()=> audio.noteOn({id, when: (startTimeSec + n.x*spb) - audio.ctx.currentTime}));
  }
  // Clips por canal (último clip de cada canal)
  for (const m of Object.values(audio.mixer)){
    const last=m.clipBuffers?.at(-1); if (!last) continue;
    if (last.type==='buffer'){
      const src=audio.ctx.createBufferSource(); src.buffer=last.buffer; src.connect(m.gainNode); src.start(startTimeSec);
    }else{
      const el=new Audio(last.url); const node=audio.ctx.createMediaElementSource(el); node.connect(m.gainNode);
      const delay=Math.max(0,(startTimeSec-audio.ctx.currentTime)); setTimeout(()=>{ el.currentTime=0; el.play(); }, delay*1000);
    }
  }
}
let loopTimeout=null;
function startMaster(){
  if (audio.ctx.state==='suspended') audio.ctx.resume();
  transport.playing=true; transport.startMs=performance.now();
  btnPlay.textContent='⏹ Stop';
  const start=audio.ctx.currentTime+0.05;
  const spb=60/roll.tempo; const loopLen=roll.bars*4*spb;
  schedulePatternOnce(start); requestAnimationFrame(drawNotes);
  if (transport.loop){
    loopTimeout=setTimeout(function scheduleNext(t){ schedulePatternOnce(t); loopTimeout=setTimeout(scheduleNext,(loopLen*1000)-60,t+loopLen); }, (loopLen*1000)-60, start+loopLen);
  }else{ loopTimeout=setTimeout(()=> stopMaster(), (loopLen*1000)+200); }
}
function stopMaster(){
  transport.playing=false; btnPlay.textContent='▶ Play';
  if (loopTimeout){ clearTimeout(loopTimeout); loopTimeout=null; }
  audio.stopAll(); drawNotes();
}

/* ==================== GRABACIÓN MASTER (MediaRecorder) ==================== */
let masterRec=null, masterChunks=[];
btnRec.onclick=()=>{
  if (!masterRec){
    const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
    masterRec = new MediaRecorder(audio.masterTap.stream, {mimeType:mime});
    masterChunks=[];
    masterRec.ondataavailable = e=> masterChunks.push(e.data);
    masterRec.onstop = ()=>{
      const blob = new Blob(masterChunks, {type: masterRec.mimeType});
      const url = URL.createObjectURL(blob);
      const a=document.createElement('a'); a.href=url; a.download='master_mix.webm'; a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    };
    masterRec.start();
    btnRec.textContent='■ Grabando Master'; btnRec.classList.add('rec');
  }else{
    try{ masterRec.stop(); }catch(_){}
    masterRec=null; btnRec.textContent='Grabar Master'; btnRec.classList.remove('rec');
  }
};
</script>
</body>
</html>
