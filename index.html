<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Mini-DAW: Sampler + Drum Roll + Mixer</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<!-- MP3 encoder -->
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
<style>
  :root{
    --bg:#0b0f14; --panel:#131a22; --accent:#6b9cff; --text:#e8eef5; --muted:#8ba0b3;
    --ok:#2ecc71; --warn:#f1c40f; --danger:#ff5a5f;
    --radius:14px;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:linear-gradient(180deg,#0b0f14 0%, #0e141b 100%); color:var(--text);
    font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; height:100vh; display:flex; flex-direction:column;
  }
  header{
    display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid #0f2030;
    background:rgba(255,255,255,0.02); backdrop-filter: blur(8px);
  }
  header .brand{font-weight:700; letter-spacing:.5px}
  header .sp{flex:1}
  header .btn{padding:8px 12px; border:1px solid #18324a; border-radius:12px; background:#0f1620; color:var(--text); cursor:pointer}
  header .btn:hover{border-color:#29527a}
  main{flex:1; display:grid; grid-template-columns: 260px 1fr; gap:12px; padding:12px; overflow:hidden}
  /* Left : instruments */
  #left{
    background:var(--panel); border:1px solid #152231; border-radius:var(--radius); padding:12px; display:flex; flex-direction:column;
    overflow:auto; min-height:0;
  }
  #left h3{margin:0 0 8px 0; font-size:14px; color:var(--muted); text-transform:uppercase; letter-spacing:.08em}
  .inst-btn{
    width:100%; padding:10px 12px; margin-bottom:8px; border:1px dashed #2a3a4d; background:#0e1520; color:var(--text);
    border-radius:12px; text-align:left; cursor:pointer; display:flex; align-items:center; justify-content:space-between;
  }
  .inst-btn:hover{border-style:solid; border-color:#335e98; background:#111b2a}
  .tag{font-size:11px; color:#a7bed3; padding:2px 6px; border:1px solid #2a3a4d; border-radius:999px}
  /* Center : drum roll + mixer wrapper */
  #center{display:grid; grid-template-rows: auto 1fr auto; gap:12px; min-height:0}
  /* Piano roll toolbar */
  #rollbar{
    background:var(--panel); border:1px solid #152231; border-radius:var(--radius);
    padding:10px; display:flex; align-items:center; gap:10px;
  }
  .seg{display:flex; gap:8px; align-items:center}
  .seg label{font-size:12px; color:var(--muted)}
  .chips{display:flex; gap:6px; flex-wrap:wrap}
  .chip{
    padding:6px 10px; border:1px solid #244059; background:#0f1823; border-radius:10px; cursor:pointer; font-size:12px; color:#cfe0f3;
  }
  .chip.active{border-color:var(--accent); background:rgba(107,156,255,.15)}
  .playbtn{
    padding:10px 14px; border:1px solid #23425e; background:#122033; color:var(--text);
    border-radius:12px; cursor:pointer; font-weight:600;
  }
  .playbtn.playing{border-color:var(--ok); color:#eafff1}
  /* Drum roll canvas */
  #rollwrap{
    background:var(--panel); border:1px solid #152231; border-radius:var(--radius); padding:10px; position:relative; min-height:0;
    display:flex; flex-direction:column; gap:10px;
  }
  #rollCanvas{width:100%; height:360px; border-radius:10px; background:#0f141b; border:1px solid #213044}
  .hint{font-size:12px; color:#9fb4c8}
  /* Mixer */
  #mixer{
    background:var(--panel); border:1px solid #152231; border-radius:var(--radius);
    padding:12px; display:flex; gap:12px; overflow:auto;
  }
  .strip{
    min-width:180px; background:#0f1620; border:1px solid #203047; border-radius:12px; padding:10px; display:flex; flex-direction:column; gap:8px;
  }
  .strip h4{margin:0; font-size:13px}
  .fader{appearance:none; width:100%; height:6px; background:#1e2a3a; border-radius:999px; outline:none}
  .fader::-webkit-slider-thumb{appearance:none; width:14px; height:14px; border-radius:50%; background:var(--accent); cursor:pointer}
  .small{font-size:11px; color:#a9bfd3}
  .meter{height:6px; background:linear-gradient(90deg,#2ecc71,#f1c40f,#ff5a5f); border-radius:999px; opacity:.6}
  .rowlabels{
    position:absolute; left:12px; top:12px; bottom:12px; width:140px; pointer-events:none; color:#cfe0f3; font-size:12px; text-shadow:0 1px 0 rgba(0,0,0,.6);
  }
  /* Instrument window (draggable) */
  .inst-win{
    position:fixed; top:120px; left:120px; width:460px; border-radius:16px; overflow:hidden; border:1px solid #264562;
    background:#0d1218; box-shadow:0 20px 60px rgba(0,0,0,.5); z-index:50;
  }
  .inst-title{
    display:flex; align-items:center; justify-content:space-between; padding:10px 12px; background:rgba(0,0,0,.35);
    border-bottom:1px solid #1b2b3c; cursor:move; user-select:none;
  }
  .inst-title .name{font-weight:700}
  .inst-title .x{width:28px; height:28px; display:grid; place-items:center; border:1px solid #2b4157; border-radius:8px; cursor:pointer}
  .inst-bg{height:120px; background:#111; background-size:cover; background-position:center;}
  .inst-ctrls{display:flex; gap:10px; padding:10px; flex-wrap:wrap}
  .knob{flex:1 1 100px; background:#0f1620; border:1px solid #223247; border-radius:12px; padding:8px}
  .knob label{display:block; font-size:11px; color:#9ab0c6; margin-bottom:6px}
  .knob input{width:100%}
  .row{display:flex; gap:10px; align-items:center}
  .kbdhint{padding:8px 10px; color:#cfe0f3; font-size:12px}
  .inst-actions{display:flex; gap:10px; padding:0 10px 10px}
  .btn2{padding:8px 10px; border:1px solid #244059; background:#0f1823; color:var(--text); border-radius:10px; cursor:pointer;}
  .btn2:hover{border-color:#335e98}
</style>
</head>
<body>
<header>
  <div class="brand">Mini-DAW</div>
  <div class="sp"></div>
  <button id="recBtn" class="btn">● Grabar todo (Master)</button>
  <button id="stopRecBtn" class="btn">⏹ Detener & Descargar</button>
  <button id="exportMp3Btn" class="btn">⬇ Exportar Arreglo a MP3</button>
</header>

<main>
  <!-- LEFT: instrumentos -->
  <aside id="left">
    <h3>Instrumentos Melódicos</h3>
    <button class="inst-btn" data-id="1">
      MUSSETE N364 <span class="tag">WAV</span>
    </button>
    <button class="inst-btn" data-id="2">
      ACORDEON KAWAI FS690 <span class="tag">WAV</span>
    </button>
    <button class="inst-btn" data-id="3">
      HONKYTONK XP10 <span class="tag">WAV</span>
    </button>
    <div class="small" style="margin-top:8px">
      Clic en un instrumento para abrir su ventana y tocar con el teclado.<br>
      Usa el botón "Agregar canal al mixer" para crear su canal.
    </div>
    <hr style="opacity:.1;margin:12px 0">
    <h3>Drum Machine</h3>
    <div class="small">
      El Piano Roll derecho ahora dispara samples fijos por fila (kick, snare, etc.).<br>
      Al poner un bloque de una fila se creará su canal en el mixer si no existe.
    </div>
  </aside>

  <!-- CENTER: drum roll + mixer -->
  <section id="center">
    <div id="rollbar">
      <button id="playBtn" class="playbtn">▶ Play</button>
      <div class="seg">
        <button id="loopBtn" class="chip">Loop OFF</button>
      </div>
      <div class="seg"><label>Tempo</label>
        <input id="tempo" type="number" min="40" max="220" value="120" class="btn" style="width:80px;text-align:center">
      </div>
      <div class="seg"><label>Grid</label>
        <div id="gridChips" class="chips"></div>
      </div>
      <div class="seg"><label>Compases</label>
        <input id="bars" type="number" min="1" max="64" value="4" class="btn" style="width:80px;text-align:center">
      </div>
      <div class="sp"></div>
      <div class="seg small">Click para crear golpe · Arrastra borde para estirar · Arrastra centro para mover</div>
    </div>

    <div id="rollwrap">
      <div class="rowlabels" id="rowLabels"></div>
      <canvas id="rollCanvas" width="1400" height="360"></canvas>
      <div class="hint">Drum rows: Kick, Snare, CH, OH, Clap, Tom, Rim, Perc</div>
    </div>

    <div id="mixer">
      <!-- strips se crean dinámicamente -->
    </div>
  </section>
</main>

<!-- ========= JS ========= -->
<script>
/* ======================= AUDIO CORE ======================= */
const audio = {
  ctx: new (window.AudioContext || window.webkitAudioContext)(),
  master: null,
  mediaDest: null,
  recorder: null,
  chunks: [],
  buffers: {}, // instId(string|number) -> AudioBuffer
  instruments: {
    // Melódicos (IDs numéricos)
    1: { name:"MUSSETE N364", wav:"wavs/MUSSETE N364.wav", bg:"imgs/mussete.jpg",
         adsr:{attack:.03,decay:.15,sustain:.7,release:.4}, cutoff:6000, gain:.9, pan:0 },
    2: { name:"ACORDEON KAWAI FS690", wav:"wavs/ACORDEON KAWAI FS690.wav", bg:"imgs/kawai.jpg",
         adsr:{attack:.02,decay:.12,sustain:.75,release:.35}, cutoff:5500, gain:.9, pan:-0.1 },
    3: { name:"HONKYTONK XP10", wav:"wavs/HONKYTONK XP10.wav", bg:"imgs/honky.jpg",
         adsr:{attack:.01,decay:.2,sustain:.6,release:.3}, cutoff:6500, gain:.9, pan:+0.1 },
    // DRUMS (IDs string con prefijo d_)
    "d_kick": { name:"Kick", wav:"wavs/kick.wav", adsr:{attack:0,decay:.01,sustain:1,release:.05}, cutoff:12000, gain:1, pan:0 },
    "d_snare":{ name:"Snare", wav:"wavs/snare.wav", adsr:{attack:0,decay:.01,sustain:1,release:.08}, cutoff:12000, gain:1, pan:0 },
    "d_ch":   { name:"Closed Hat", wav:"wavs/hat_closed.wav", adsr:{attack:0,decay:.01,sustain:1,release:.02}, cutoff:12000, gain:.9, pan:0 },
    "d_oh":   { name:"Open Hat", wav:"wavs/hat_open.wav", adsr:{attack:0,decay:.01,sustain:1,release:.2}, cutoff:12000, gain:.9, pan:0 },
    "d_clap": { name:"Clap", wav:"wavs/clap.wav", adsr:{attack:0,decay:.01,sustain:1,release:.08}, cutoff:12000, gain:1, pan:0 },
    "d_tom":  { name:"Tom", wav:"wavs/tom.wav", adsr:{attack:0,decay:.01,sustain:1,release:.1}, cutoff:12000, gain:1, pan:0 },
    "d_rim":  { name:"Rim", wav:"wavs/rim.wav", adsr:{attack:0,decay:.01,sustain:1,release:.05}, cutoff:12000, gain:1, pan:0 },
    "d_perc": { name:"Perc", wav:"wavs/perc.wav", adsr:{attack:0,decay:.01,sustain:1,release:.12}, cutoff:12000, gain:1, pan:0 },
  },
  // filas fijas del drum roll (en orden visual)
  drumRows: ["d_kick","d_snare","d_ch","d_oh","d_clap","d_tom","d_rim","d_perc"],
  mixer: {}, // instId -> {gainNode, panNode, meterVal, rec:{dest,recorder,chunks,clips[]}}
  recordedClips: {}, // instId -> [Blob, ...]
  init(){
    this.master = this.ctx.createGain();
    this.master.gain.value = 1;
    const pan = this.ctx.createStereoPanner(); // master center
    this.master.connect(pan).connect(this.ctx.destination);
    // grabador master
    this.mediaDest = this.ctx.createMediaStreamDestination();
    this.master.connect(this.mediaDest);
  },
  async loadBuffer(instId){
    const inst = this.instruments[instId];
    if (!inst || this.buffers[instId]) return;
    const res = await fetch(inst.wav);
    if (!res.ok) throw new Error("No se pudo cargar: "+inst.wav);
    const arr = await res.arrayBuffer();
    this.buffers[instId] = await this.ctx.decodeAudioData(arr);
  },
  // Note on: si drum (id empieza con d_), reproduce a rate=1; si melódico, semitone-based
  noteOn({instId, semitoneFromC3=0, when=0, destNode=null, adsrOverride=null, cutoffOverride=null, rate=null}){
    const ctx = this.ctx;
    const buf = this.buffers[instId];
    if (!buf) return null;

    const source = ctx.createBufferSource();
    source.buffer = buf;

    // Pitch o rate
    if (rate!=null) source.playbackRate.value = rate;
    else if (String(instId).startsWith("d_")) source.playbackRate.value = 1;
    else source.playbackRate.value = Math.pow(2, semitoneFromC3/12);

    const filter = ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = cutoffOverride ?? this.instruments[instId].cutoff;

    const amp = ctx.createGain();
    const gnode = destNode || this.mixer[instId]?.gainNode || this.master;

    source.connect(filter).connect(amp).connect(gnode);

    // ADSR
    const A = adsrOverride?.attack  ?? this.instruments[instId].adsr.attack;
    const D = adsrOverride?.decay   ?? this.instruments[instId].adsr.decay;
    const S = adsrOverride?.sustain ?? this.instruments[instId].adsr.sustain;
    const R = adsrOverride?.release ?? this.instruments[instId].adsr.release;
    const maxGain = this.instruments[instId].gain;

    const t0 = ctx.currentTime + when;
    amp.gain.cancelScheduledValues(t0);
    amp.gain.setValueAtTime(0, t0);
    amp.gain.linearRampToValueAtTime(maxGain, t0 + A);
    amp.gain.linearRampToValueAtTime(maxGain * S, t0 + A + D);

    source.start(t0);
    return {source, amp, R, start:t0};
  },
  noteOff(handle){
    if (!handle) return;
    const now = this.ctx.currentTime;
    const g = handle.amp.gain;
    g.cancelScheduledValues(now);
    g.setValueAtTime(g.value, now);
    g.linearRampToValueAtTime(0, now + handle.R);
    try { handle.source.stop(now + handle.R + .03); } catch(e){}
  }
};
audio.init();

/* ======================= MIXER UI ======================= */
const mixerEl = document.getElementById('mixer');

// Hash para colores por id
function colorHash(id){
  let h=0; const s = String(id);
  for (let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i))>>>0;
  return h % 360;
}

function ensureStrip(instId){
  if (audio.mixer[instId]) return audio.mixer[instId];
  const inst = audio.instruments[instId];
  if (!inst) return null;
  return makeStrip(instId);
}

function makeStrip(instId){
  const inst = audio.instruments[instId];
  const strip = document.createElement('div');
  strip.className = 'strip';
  strip.innerHTML = `
    <h4>${inst.name}</h4>
    <div class="small">Volumen</div>
    <input class="fader" type="range" min="0" max="1" step="0.01" value="${inst.gain}" data-vol="${instId}">
    <div class="small">Pan</div>
    <input class="fader" type="range" min="-1" max="1" step="0.01" value="${inst.pan}" data-pan="${instId}">
    <div class="small">Nivel</div>
    <div class="meter" id="meter-${instId}"></div>
    <div class="row" style="justify-content:space-between">
      <button class="btn2" data-rec="${instId}">● Rec canal</button>
      <span class="small" id="recstat-${instId}">Idle</span>
    </div>
  `;
  mixerEl.appendChild(strip);

  // nodes
  const gainNode = audio.ctx.createGain(); gainNode.gain.value = inst.gain;
  const panNode = audio.ctx.createStereoPanner(); panNode.pan.value = inst.pan;
  gainNode.connect(panNode).connect(audio.master);

  // Grabador individual (en memoria)
  const dest = audio.ctx.createMediaStreamDestination();
  // Duplicamos la salida hacia el destino del canal
  panNode.connect(dest);

  const recObj = {
    dest,
    recorder: null,
    chunks: [],
    clips: [] // Blobs guardados en memoria
  };

  audio.mixer[instId] = {gainNode, panNode, meterVal:0, rec:recObj};

  strip.querySelector('[data-vol]').addEventListener('input', e=>{
    const v = parseFloat(e.target.value);
    inst.gain = v;
    audio.mixer[instId].gainNode.gain.value = v;
  });
  strip.querySelector('[data-pan]').addEventListener('input', e=>{
    const p = parseFloat(e.target.value);
    inst.pan = p;
    audio.mixer[instId].panNode.pan.value = p;
  });

  // Rec por canal
  const recBtn = strip.querySelector(`[data-rec="${instId}"]`);
  const stat = strip.querySelector(`#recstat-${instId}`);
  recBtn.addEventListener('click', ()=>{
    const r = audio.mixer[instId].rec;
    if (!r.recorder){
      const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
      r.recorder = new MediaRecorder(r.dest.stream, {mimeType:mime});
      r.recorder.ondataavailable = e=> r.chunks.push(e.data);
      r.recorder.onstop = ()=>{
        const blob = new Blob(r.chunks, {type: r.recorder.mimeType});
        r.chunks = [];
        r.clips.push(blob);
        audio.recordedClips[instId] = r.clips;
        stat.textContent = `Guardado (${r.clips.length})`;
      };
    }

    if (r.recorder.state!=='recording'){
      r.chunks = [];
      r.recorder.start();
      recBtn.textContent = '⏹ Detener';
      stat.textContent = 'Grabando...';
    }else{
      r.recorder.stop();
      recBtn.textContent = '● Rec canal';
      // stat se actualiza en onstop
    }
  });

  return audio.mixer[instId];
}

/* ======================= INSTRUMENT WINDOW (DRAGGABLE) ======================= */
let currentInstrumentId = null;
function openInstrument(instId){
  const inst = audio.instruments[instId];
  currentInstrumentId = instId;

  const win = document.createElement('div');
  win.className = 'inst-win';
  win.innerHTML = `
    <div class="inst-title">
      <div class="name">${inst.name}</div>
      <div class="x" title="Cerrar">✕</div>
    </div>
    <div class="inst-bg" style="background-image:url('${inst.bg || ""}')"></div>
    <div class="inst-ctrls">
      <div class="knob"><label>Gain</label><input type="range" min="0" max="1" step="0.01" value="${inst.gain}" data-k="gain"></div>
      <div class="knob"><label>Attack</label><input type="range" min="0" max="2" step="0.01" value="${inst.adsr.attack}" data-k="attack"></div>
      <div class="knob"><label>Decay</label><input type="range" min="0" max="2" step="0.01" value="${inst.adsr.decay}" data-k="decay"></div>
      <div class="knob"><label>Sustain</label><input type="range" min="0" max="1" step="0.01" value="${inst.adsr.sustain}" data-k="sustain"></div>
      <div class="knob"><label>Release</label><input type="range" min="0" max="4" step="0.01" value="${inst.adsr.release}" data-k="release"></div>
      <div class="knob"><label>Cutoff</label><input type="range" min="100" max="12000" step="1" value="${inst.cutoff}" data-k="cutoff"></div>
    </div>
    <div class="inst-actions">
      <button class="btn2" id="addStripBtn">＋ Agregar canal al mixer</button>
      <button class="btn2" id="testNoteBtn">Probar nota</button>
    </div>
    <div class="kbdhint">Toca con el teclado: A W S E D F T G Y H U J K (C3..C4)</div>
  `;
  document.body.appendChild(win);

  // close
  win.querySelector('.x').onclick = ()=> win.remove();

  // drag
  const header = win.querySelector('.inst-title');
  let dragging=false, offX=0, offY=0;
  header.addEventListener('mousedown', e=>{
    dragging=true; offX=e.clientX - win.offsetLeft; offY=e.clientY - win.offsetTop;
    document.body.style.userSelect='none';
  });
  document.addEventListener('mousemove', e=>{
    if(!dragging) return;
    let x = e.clientX - offX, y = e.clientY - offY;
    x = Math.max(8, Math.min(x, window.innerWidth - win.offsetWidth - 8));
    y = Math.max(8, Math.min(y, window.innerHeight - win.offsetHeight - 8));
    win.style.left = x+'px'; win.style.top = y+'px';
  });
  document.addEventListener('mouseup', ()=>{ dragging=false; document.body.style.userSelect='' });

  // knobs
  win.querySelectorAll('input[type="range"]').forEach(r=>{
    r.addEventListener('input', e=>{
      const k = e.target.dataset.k;
      const v = parseFloat(e.target.value);
      if (k === 'gain'){ inst.gain = v; if(audio.mixer[instId]) audio.mixer[instId].gainNode.gain.value = v; }
      else if (k === 'cutoff'){ inst.cutoff = v; }
      else { inst.adsr[k] = v; }
    });
  });

  // crear canal en mixer
  win.querySelector('#addStripBtn').onclick = ()=> ensureStrip(instId);

  // test note
  win.querySelector('#testNoteBtn').onclick = async ()=>{
    if (audio.ctx.state==='suspended') await audio.ctx.resume();
    await audio.loadBuffer(instId).catch(()=>{});
    const h = audio.noteOn({instId, semitoneFromC3:0});
    setTimeout(()=> audio.noteOff(h), 400);
  };

  // load buffer
  audio.loadBuffer(instId).catch(err=> console.warn(err));
}

// Left buttons
document.querySelectorAll('.inst-btn').forEach(btn=>{
  btn.addEventListener('click', ()=> openInstrument(parseInt(btn.dataset.id,10)));
});

/* ======================= KEYBOARD PLAY (live para melódicos) ======================= */
const keyToSemitone = { a:0,w:1,s:2,e:3,d:4,f:5,t:6,g:7,y:8,h:9,u:10,j:11,k:12 };
const liveActive = new Map(); // key -> handle
document.addEventListener('keydown', async (e)=>{
  if (e.repeat) return;
  if (!currentInstrumentId) return;
  const k = e.key.toLowerCase();
  if (!(k in keyToSemitone)) return;
  if (String(currentInstrumentId).startsWith("d_")) return; // no toca drums desde teclado
  if (audio.ctx.state==='suspended') await audio.ctx.resume();
  await audio.loadBuffer(currentInstrumentId).catch(()=>{});
  const handle = audio.noteOn({
    instId: currentInstrumentId,
    semitoneFromC3:keyToSemitone[k]
  });
  liveActive.set(k, handle);
});
document.addEventListener('keyup', (e)=>{
  const k = e.key.toLowerCase();
  const h = liveActive.get(k);
  if (h){ audio.noteOff(h); liveActive.delete(k); }
});

/* ======================= DRUM ROLL ======================= */
const rollCanvas = document.getElementById('rollCanvas');
const rctx = rollCanvas.getContext('2d');
const rowLabelsEl = document.getElementById('rowLabels');

const roll = {
  quant: 1/4,
  bars: 4,
  tempo: 120,
  pxPerBeat: 80,
  rowH: 40,
  rows: 8, // drumRows
  notes: [], // {x, len, row, instId}
  dragging: null,
  playing: false,
  startMs: 0,
  loop: false
};
function quantizeBeat(b){ const q = roll.quant; return Math.round(b/q)*q; }
function beatsToPx(b){ return b*roll.pxPerBeat; }
function pxToBeats(px){ return px/roll.pxPerBeat; }
function totalBeats(){ return roll.bars*4; }
function songMs(){ const beats = totalBeats(); const spb=60/roll.tempo; return beats*spb*1000; }

function refreshRowLabels(){
  const labels = audio.drumRows.map(id=> audio.instruments[id]?.name || id);
  let html = '';
  for (let r=0; r<roll.rows; r++){
    const y = r*roll.rowH;
    html += `<div style="position:absolute; top:${y+10}px; left:8px; width:120px; text-overflow:ellipsis; white-space:nowrap; overflow:hidden;">${labels[r]||''}</div>`;
  }
  rowLabelsEl.innerHTML = html;
}
refreshRowLabels();

// grid chips
const grids = [1,1/2,1/4,1/8,1/16,1/32];
const gridChips = document.getElementById('gridChips');
grids.forEach(g=>{
  const chip = document.createElement('div');
  const label = (g===1)?'1/1':(g===0.5)?'1/2':`1/${1/g}`;
  chip.className='chip'+(g===roll.quant?' active':'');
  chip.textContent = label;
  chip.onclick = ()=>{
    roll.quant=g;
    [...gridChips.children].forEach(c=>c.classList.remove('active'));
    chip.classList.add('active');
    drawRoll();
  };
  gridChips.appendChild(chip);
});

// tempo & bars & loop
document.getElementById('tempo').addEventListener('input', e=>{ roll.tempo = Math.max(40, Math.min(220, +e.target.value||120)); });
document.getElementById('bars').addEventListener('input', e=>{ roll.bars = Math.max(1, Math.min(64, +e.target.value||4)); drawRoll(); });
const loopBtn = document.getElementById('loopBtn');
loopBtn.onclick = ()=>{
  roll.loop = !roll.loop;
  loopBtn.textContent = roll.loop ? 'Loop ON' : 'Loop OFF';
  loopBtn.classList.toggle('active', roll.loop);
};

function drawRoll(){
  const W = rollCanvas.width, H = rollCanvas.height;
  rctx.clearRect(0,0,W,H);

  // background rows
  for (let r=0; r<roll.rows; r++){
    rctx.fillStyle = (r%2===0)?'#0f141b':'#0d1117';
    rctx.fillRect(0, r*roll.rowH, W, roll.rowH);
  }

  // vertical grid
  const beats = totalBeats();
  for (let b=0; b<=beats; b+=roll.quant){
    const x = Math.floor(beatsToPx(b)) + .5;
    rctx.strokeStyle = (Math.abs(b - Math.round(b))<1e-6) ? '#2a3a4f' : '#1e2a3c';
    rctx.lineWidth = (Math.abs(b - Math.round(b))<1e-6) ? 1.5 : 1;
    rctx.beginPath(); rctx.moveTo(x,0); rctx.lineTo(x,H); rctx.stroke();
  }

  // notes (bloques)
  for (const n of roll.notes){
    const x = Math.floor(beatsToPx(n.x)) + .5;
    const w = Math.max(6, Math.floor(beatsToPx(n.len)));
    const y = n.row*roll.rowH + 6;
    const h = roll.rowH - 12;
    const hue = colorHash(n.instId);
    rctx.fillStyle = `hsl(${hue} 70% 55% / .85)`;
    rctx.fillRect(x, y, w, h);
    rctx.strokeStyle = `hsl(${hue} 80% 35%)`;
    rctx.strokeRect(x, y, w, h);
    rctx.fillStyle = '#ffffff';
    rctx.fillRect(x+w-5, y, 5, h); // handle
  }

  // playhead
  if (roll.playing){
    const t = (performance.now() - roll.startMs);
    const x = 0.5 + (t/songMs()) * beatsToPx(totalBeats());
    rctx.strokeStyle = '#ff4d4f';
    rctx.lineWidth = 2;
    rctx.beginPath(); rctx.moveTo(x,0); rctx.lineTo(x,H); rctx.stroke();
    requestAnimationFrame(drawRoll);
  }
}
drawRoll();

// mouse interaction
rollCanvas.addEventListener('mousedown', (e)=>{
  const rect = rollCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const b = pxToBeats(mx);
  const r = Math.max(0, Math.min(roll.rows-1, Math.floor(my/roll.rowH)));

  // check existing note
  for (let i=roll.notes.length-1; i>=0; i--){
    const n = roll.notes[i];
    const x = beatsToPx(n.x);
    const w = beatsToPx(n.len);
    const y = n.row*roll.rowH + 6;
    const h = roll.rowH - 12;
    if (mx>=x && mx<=x+w && my>=y && my<=y+h){
      if (mx>=x+w-6){ // resize
        roll.dragging = {note:n, dx:n.x - b, dy:n.row - r, type:'resize'};
      }else{ // move
        roll.dragging = {note:n, dx:n.x - b, dy:n.row - r, type:'move'};
      }
      return;
    }
  }

  // create new drum note
  const sampleId = audio.drumRows[r];
  const xBeat = quantizeBeat(pxToBeats(mx));
  const newNote = {x:xBeat, len: Math.max(roll.quant, 1*roll.quant), row:r, instId:sampleId};
  roll.notes.push(newNote);
  roll.dragging = {note:newNote, dx:0, dy:0, type:'resize'};
  // aseguro buffer y canal en mixer
  audio.loadBuffer(sampleId).catch(()=>{});
  ensureStrip(sampleId);
  drawRoll();
});
window.addEventListener('mousemove', (e)=>{
  if (!roll.dragging) return;
  const rect = rollCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const b = pxToBeats(mx);
  const r = Math.floor(my/roll.rowH);
  const n = roll.dragging.note;

  if (roll.dragging.type==='move'){
    n.x = Math.max(0, quantizeBeat(b + roll.dragging.dx));
    n.row = Math.max(0, Math.min(roll.rows-1, r + roll.dragging.dy));
    n.instId = audio.drumRows[n.row]; // mantener sample por fila
  }else{
    const newLen = Math.max(roll.quant, quantizeBeat(b - n.x));
    n.len = newLen;
  }
  drawRoll();
});
window.addEventListener('mouseup', ()=> roll.dragging = null);

/* ======================= PLAYBACK (drum + live) ======================= */
const playBtn = document.getElementById('playBtn');
playBtn.onclick = ()=>{ if (roll.playing) stopPlay(); else startPlay(); };

let scheduled = [];
async function scheduleAll(t0){
  // asegurar buffers existentes (drums usados)
  const usedIds = new Set(roll.notes.map(n=> n.instId));
  for (const id of usedIds) { try{ await audio.loadBuffer(id); }catch(e){} }
  // schedule notas
  const spb = 60/roll.tempo;
  for (const n of roll.notes){
    const whenBeat = n.x;
    const whenSec = whenBeat*spb;
    const handle = audio.noteOn({
      instId:n.instId,
      semitoneFromC3:0,
      when: (t0 ? (t0 - audio.ctx.currentTime) : 0) + whenSec
    });
    const offSec = (n.x+n.len)*spb;
    scheduled.push({handle, offAt:(t0 || audio.ctx.currentTime) + offSec});
  }
}

async function startPlay(){
  if (audio.ctx.state==='suspended') await audio.ctx.resume();
  roll.playing = true; roll.startMs = performance.now();
  playBtn.classList.add('playing'); playBtn.textContent='⏹ Stop';
  scheduled = [];
  const startT = audio.ctx.currentTime;
  await scheduleAll(startT);

  // animación y loop
  const loopEndMs = songMs();
  const tick = ()=>{
    if (!roll.playing) return;
    // note offs
    const now = audio.ctx.currentTime;
    for (const s of scheduled){ if (!s.done && now>=s.offAt){ audio.noteOff(s.handle); s.done=true; } }
    // playhead
    const elapsed = performance.now() - roll.startMs;
    if (elapsed < loopEndMs) requestAnimationFrame(drawRoll);
    else{
      if (roll.loop){
        roll.startMs = performance.now();
        scheduled = [];
        scheduleAll(audio.ctx.currentTime);
        requestAnimationFrame(drawRoll);
        setTimeout(tick, 0);
        return;
      }else{
        stopPlay();
        return;
      }
    }
    setTimeout(tick, 25);
  };
  requestAnimationFrame(drawRoll);
  tick();
}
function stopPlay(){
  roll.playing = false;
  for (const s of scheduled){ if (s.handle) audio.noteOff(s.handle); }
  scheduled = [];
  playBtn.classList.remove('playing'); playBtn.textContent='▶ Play';
  drawRoll();
}

/* ======================= LIVE RECORDING MASTER (MediaRecorder .webm) ======================= */
const recBtn = document.getElementById('recBtn');
const stopRecBtn = document.getElementById('stopRecBtn');
recBtn.onclick = async ()=>{
  if (audio.ctx.state==='suspended') await audio.ctx.resume();
  if (!audio.recorder){
    const stream = audio.mediaDest.stream;
    const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
    audio.recorder = new MediaRecorder(stream, {mimeType:mime});
    audio.recorder.ondataavailable = e=> audio.chunks.push(e.data);
    audio.recorder.onstop = ()=>{
      const blob = new Blob(audio.chunks, {type: audio.recorder.mimeType});
      audio.chunks = [];
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'master_recording.webm';
      a.click();
      URL.revokeObjectURL(url);
      audio.recorder = null;
    };
  }
  audio.chunks = [];
  audio.recorder.start();
  recBtn.textContent='● Grabando master...';
  recBtn.style.color = '#ffb3b3';
};
stopRecBtn.onclick = ()=>{
  if (audio.recorder && audio.recorder.state!=='inactive'){
    audio.recorder.stop();
    recBtn.textContent='● Grabar todo (Master)';
    recBtn.style.color='';
  }
};

/* ======================= EXPORT ARREGLO A MP3 (Offline render) ======================= */
document.getElementById('exportMp3Btn').onclick = async ()=>{
  const spb = 60/roll.tempo;
  const lengthSec = totalBeats()*spb + 4; // cola
  const sampleRate = 44100;
  const offline = new OfflineAudioContext(2, Math.ceil(lengthSec*sampleRate), sampleRate);

  // build mixer busses (para todos los ids presentes en la sesión)
  const allIds = new Set([
    ...Object.keys(audio.instruments) // exporta cualquier instrumento que exista y tenga notas
  ]);
  // solo creamos buses para los que usaremos; pero mantener general no afecta.
  const busses = {};
  for (const id of allIds){
    const inst = audio.instruments[id];
    if (!inst) continue;
    const g = offline.createGain(); g.gain.value = inst.gain;
    const p = offline.createStereoPanner(); p.pan.value = inst.pan;
    g.connect(p).connect(offline.destination);
    busses[id] = {g,p};
  }

  // asegurar buffers en main ctx (clonaremos)
  // solo para los que tienen notas
  const used = new Set(roll.notes.map(n=> n.instId));
  for (const id of used){
    if (!audio.buffers[id]){ try { await audio.loadBuffer(id); } catch(e){} }
  }

  // schedule drum notes
  for (const n of roll.notes){
    const mainBuf = audio.buffers[n.instId];
    if (!mainBuf) continue;
    const src = offline.createBufferSource();
    const clone = offline.createBuffer(mainBuf.numberOfChannels, mainBuf.length, mainBuf.sampleRate);
    for (let ch=0; ch<mainBuf.numberOfChannels; ch++){
      clone.copyToChannel(mainBuf.getChannelData(ch), ch);
    }
    src.buffer = clone;
    src.playbackRate.value = 1; // drums
    const filt = offline.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value = audio.instruments[n.instId].cutoff;
    const amp  = offline.createGain();
    src.connect(filt).connect(amp).connect(busses[n.instId]?.g || offline.destination);

    const A=audio.instruments[n.instId].adsr.attack;
    const D=audio.instruments[n.instId].adsr.decay;
    const S=audio.instruments[n.instId].adsr.sustain;
    const R=audio.instruments[n.instId].adsr.release;
    const t0 = n.x*spb;
    amp.gain.setValueAtTime(0, t0);
    amp.gain.linearRampToValueAtTime(1, t0+A);
    amp.gain.linearRampToValueAtTime(S, t0+A+D);

    src.start(t0);
    amp.gain.setValueAtTime(amp.gain.value, (n.x+n.len)*spb);
    amp.gain.linearRampToValueAtTime(0, (n.x+n.len)*spb + R);
    try{ src.stop((n.x+n.len)*spb + R + .03);}catch(e){}
  }

  const rendered = await offline.startRendering();
  const mp3 = wavToMp3(rendered);
  const url = URL.createObjectURL(new Blob([new Uint8Array(mp3)], {type:'audio/mpeg'}));
  const a = document.createElement('a');
  a.href = url; a.download = 'arrangement.mp3'; a.click();
  URL.revokeObjectURL(url);
};

// helper: AudioBuffer -> MP3 bytes (stereo 44.1k)
function wavToMp3(abuf){
  const numCh = 2;
  const sr = abuf.sampleRate;
  const ch0 = abuf.getChannelData(0);
  const ch1 = (abuf.numberOfChannels>1)?abuf.getChannelData(1):ch0;
  const mp3encoder = new lamejs.Mp3Encoder(numCh, sr, 128);
  const blockSize = 1152;
  let mp3Data = [];

  function floatTo16BitPCM(input){
    const out = new Int16Array(input.length);
    for (let i = 0; i < input.length; i++){
      let s = Math.max(-1, Math.min(1, input[i]));
      out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return out;
  }

  for (let i=0; i<ch0.length; i+=blockSize){
    const l = ch0.subarray(i, i+blockSize);
    const r = ch1.subarray(i, i+blockSize);
    const enc = mp3encoder.encodeBuffer(floatTo16BitPCM(l), floatTo16BitPCM(r));
    if (enc.length>0) mp3Data.push(enc);
  }
  const enc = mp3encoder.flush();
  if (enc.length>0) mp3Data.push(enc);
  // concat
  let totalLen = mp3Data.reduce((a,b)=>a+b.length,0);
  const out = new Uint8Array(totalLen);
  let off=0;
  for (const chunk of mp3Data){ out.set(chunk, off); off += chunk.length; }
  return out;
}

/* ======================= LEFT LIST CLICK (abre ventana) ======================= */
document.querySelectorAll('.inst-btn').forEach(btn=>{
  btn.addEventListener('click', ()=> openInstrument(parseInt(btn.dataset.id,10)));
});
</script>
</body>
</html>
