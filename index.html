<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Mini-DAW: Mixer por instrumentos</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.0/lame.min.js"></script>
<style>
  :root{
    --bg:#0b0f14; --panel:#131a22; --accent:#6b9cff; --text:#e8eef5; --muted:#8ba0b3;
    --ok:#2ecc71; --warn:#f1c40f; --danger:#ff5a5f; --radius:14px;
  }
  *{box-sizing:border-box}
  body{margin:0; background:linear-gradient(180deg,#0b0f14 0%, #0e141b 100%); color:var(--text);
       font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; min-height:100vh; display:flex; flex-direction:column;}
  header{display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid #0f2030;
         background:rgba(255,255,255,0.02); backdrop-filter: blur(8px);}
  header .brand{font-weight:700; letter-spacing:.5px}
  header .sp{flex:1}
  header .btn{padding:8px 12px; border:1px solid #18324a; border-radius:12px; background:#0f1620; color:var(--text); cursor:pointer}
  header .btn:hover{border-color:#29527a}
  main{flex:1; display:grid; grid-template-columns: 260px 1fr; gap:12px; padding:12px; overflow:hidden}
  /* Left : instruments */
  #left{background:var(--panel); border:1px solid #152231; border-radius:var(--radius); padding:12px; display:flex; flex-direction:column; overflow:auto; min-height:0;}
  #left h3{margin:0 0 8px 0; font-size:14px; color:var(--muted); text-transform:uppercase; letter-spacing:.08em}
  .inst-btn{width:100%; padding:10px 12px; margin-bottom:8px; border:1px dashed #2a3a4d; background:#0e1520; color:var(--text);
            border-radius:12px; text-align:left; cursor:pointer; display:flex; align-items:center; justify-content:space-between;}
  .inst-btn:hover{border-style:solid; border-color:#335e98; background:#111b2a}
  .tag{font-size:11px; color:#a7bed3; padding:2px 6px; border:1px solid #2a3a4d; border-radius:999px}
  /* Center: Mixer area */
  #center{display:flex; flex-direction:column; gap:12px; min-height:0}
  #controls{background:var(--panel); border:1px solid #152231; border-radius:var(--radius); padding:10px; display:flex; gap:8px; align-items:center;}
  #mixerWrap{background:var(--panel); border:1px solid #152231; border-radius:var(--radius); padding:12px; display:flex; gap:12px; overflow:auto; min-height:320px;}
  .inst-mixer{min-width:260px; background:#0f1620; border:1px solid #203047; border-radius:12px; padding:10px; display:flex; flex-direction:column; gap:8px;}
  .inst-mixer h4{margin:0; font-size:13px}
  .channel{background:#0c1419; border:1px solid #223247; border-radius:10px; padding:8px; display:flex; flex-direction:column; gap:8px;}
  .ch-top{display:flex; gap:8px; align-items:center; justify-content:space-between}
  .fader{appearance:none; width:100%; height:6px; background:#1e2a3a; border-radius:999px; outline:none}
  .fader::-webkit-slider-thumb{appearance:none; width:14px; height:14px; border-radius:50%; background:var(--accent); cursor:pointer}
  .btn-small{padding:6px 8px; border-radius:8px; border:1px solid #223247; background:#0f1620; cursor:pointer}
  .rec-on{background:linear-gradient(90deg,#ff6b6b,#ffb3b3); color:#210000}
  .recordings{display:flex; flex-direction:column; gap:6px; max-height:160px; overflow:auto}
  .rec-item{display:flex; gap:8px; align-items:center; background:#081018; padding:6px; border-radius:8px; border:1px solid #172634}
  .small{font-size:12px; color:#a9bfd3}
  .muted{color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="brand">TIBETANO BEATS LABS — Mixer</div>
  <div class="sp"></div>
  <button id="playMixerBtn" class="btn">▶ Reproducir Mixer</button>
  <button id="stopMixerBtn" class="btn">⏹ Detener Mixer</button>
  <button id="exportMp3Btn" class="btn">⬇ Exportar Mezcla a MP3</button>
</header>

<main>
  <!-- LEFT: instrumentos -->
  <aside id="left">
    <h3>Instrumentos</h3>
    <!-- listado reducido; puedes agregar más como en tu original -->
    <button class="inst-btn" data-id="1">ACORDEON KAWAI FS690 <span class="tag">WAV</span></button>
    <button class="inst-btn" data-id="5">ACUSTIC PIANO <span class="tag">WAV</span></button>
    <button class="inst-btn" data-id="14">ELECTRIC PIANO <span class="tag">WAV</span></button>
    <button class="inst-btn" data-id="23">P5POLY XP10 <span class="tag">WAV</span></button>
    <div class="small" style="margin-top:8px">
      Haz clic en un instrumento para abrir su ventana y crear canales en el Mixer.<br>
      Cada canal puede grabar lo que su instrumento reproduce.
    </div>
  </aside>

  <!-- CENTER: mixer y controles -->
  <section id="center">
    <div id="controls">
      <div class="small muted">Controles globales:</div>
      <div style="width:8px"></div>
      <div class="small">Master Volume</div>
      <input id="masterVol" type="range" min="0" max="1" step="0.01" value="1" style="width:160px">
      <div style="flex:1"></div>
      <div class="small muted">Click instrumento → Abrir ventana → Crear canal</div>
    </div>

    <div id="mixerWrap"><!-- mixers por instrumento se agregan aquí --></div>
  </section>
</main>

<script>
/* ================= AUDIO CORE ================= */
const audio = {
  ctx: new (window.AudioContext || window.webkitAudioContext)(),
  masterGain: null, mediaDestAll: null,
  buffers: {},
  instruments: {
    1:{name:"ACORDEON KAWAI FS690", wav:"wavs/ACORDEON KAWAI FS690.wav", bg:"", adsr:{attack:.02,decay:.15,sustain:.7,release:.35}, cutoff:6000, gain:.9, pan:0},
    5:{name:"ACUSTIC PIANO", wav:"wavs/ACUSTIC PIANO.wav", bg:"", adsr:{attack:.02,decay:.15,sustain:.7,release:.35}, cutoff:6000, gain:.9, pan:0},
    14:{name:"ELECTRIC PIANO", wav:"wavs/ELECTRIC PIANO.wav", bg:"", adsr:{attack:.02,decay:.15,sustain:.7,release:.35}, cutoff:6000, gain:.9, pan:0},
    23:{name:"P5POLY XP10", wav:"wavs/P5POLY XP10.wav", bg:"", adsr:{attack:.02,decay:.15,sustain:.7,release:.35}, cutoff:6000, gain:.9, pan:0}
  },
  // estructura mixers: instrumentId -> instMixerEl, channels: [channelObj...]
  instMixers: {},
  init(){
    this.masterGain = this.ctx.createGain(); this.masterGain.gain.value = 1;
    this.masterGain.connect(this.ctx.destination);
    this.mediaDestAll = this.ctx.createMediaStreamDestination();
    // conectar master también al mediaDestAll por si quieres grabar mezcla global
    this.masterGain.connect(this.mediaDestAll);
  },
  async loadBuffer(instId){
    const inst = this.instruments[instId]; if (!inst || this.buffers[instId]) return;
    try{
      const res = await fetch(inst.wav);
      if (!res.ok) throw new Error('No se pudo cargar '+inst.wav);
      const arr = await res.arrayBuffer();
      this.buffers[instId] = await this.ctx.decodeAudioData(arr);
    }catch(err){ console.warn(err); }
  }
};
audio.init();

/* ================= UI: Mixer container por instrumento ================= */
const mixerWrap = document.getElementById('mixerWrap');
const masterVol = document.getElementById('masterVol');
masterVol.addEventListener('input', ()=>{ audio.masterGain.gain.value = +masterVol.value; });

function makeInstMixer(instId){
  if (audio.instMixers[instId]) return audio.instMixers[instId].el;
  const inst = audio.instruments[instId];
  const el = document.createElement('div');
  el.className = 'inst-mixer';
  el.innerHTML = `
    <h4>${inst.name}</h4>
    <div class="small muted">Canales</div>
    <div class="channels"></div>
    <div style="display:flex;gap:8px; margin-top:6px;">
      <button class="btn-small create-channel">➕ Crear canal</button>
    </div>
  `;
  mixerWrap.appendChild(el);

  const channelsEl = el.querySelector('.channels');

  // estructura para este instrumento
  const state = {instId, el, channelsEl, channels:[], nextChannelId:1};
  audio.instMixers[instId] = state;

  // crear canal
  el.querySelector('.create-channel').addEventListener('click', ()=> createChannelForInstrument(instId));

  return el;
}

/* ================= Channel creation and management ================= */
/*
channel object:
{
  channelId (number),
  instId,
  gainNode,
  panNode,
  mediaDest, recorder, recChunks[],
  recordings: [{blob, url, duration}],
  el (DOM),
}
*/
async function createChannelForInstrument(instId){
  if (audio.ctx.state === 'suspended') await audio.ctx.resume();
  await audio.loadBuffer(instId); // preload sample if needed

  const instMixer = audio.instMixers[instId] || makeInstMixer(instId);
  const state = audio.instMixers[instId];

  // create audio nodes for channel bus
  const gainNode = audio.ctx.createGain();
  const panNode = audio.ctx.createStereoPanner();
  gainNode.gain.value = audio.instruments[instId].gain ?? 1;
  panNode.pan.value = audio.instruments[instId].pan ?? 0;
  gainNode.connect(panNode).connect(audio.masterGain);

  // media dest for recording this channel
  const mediaDest = audio.ctx.createMediaStreamDestination();
  // connect channel bus also to mediaDest so recorder records post-fader signal
  gainNode.connect(mediaDest);

  // DOM
  const chEl = document.createElement('div');
  chEl.className = 'channel';
  const id = state.nextChannelId++;

  chEl.innerHTML = `
    <div class="ch-top">
      <div style="display:flex;align-items:center;gap:8px">
        <strong>Canal ${id}</strong>
        <div class="small muted">(${audio.instruments[instId].name})</div>
      </div>
      <div style="display:flex;gap:6px">
        <button class="btn-small remove-ch">Eliminar</button>
      </div>
    </div>
    <div>
      <div class="small">Vol</div>
      <input class="fader ch-vol" type="range" min="0" max="1" step="0.01" value="${gainNode.gain.value}">
      <div class="small">Pan</div>
      <input class="fader ch-pan" type="range" min="-1" max="1" step="0.01" value="${panNode.pan.value}">
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <button class="btn-small rec-btn">● Grabar</button>
      <button class="btn-small stop-rec-btn" disabled>■ Detener</button>
      <button class="btn-small play-last" disabled>▶ Play última</button>
    </div>
    <div class="small muted">Grabaciones</div>
    <div class="recordings"></div>
  `;
  state.channelsEl.appendChild(chEl);

  // channel object
  const channel = {
    channelId: id,
    instId,
    gainNode,
    panNode,
    mediaDest,
    recorder: null,
    recChunks: [],
    recordings: [], // {blob, url, duration}
    el: chEl
  };

  // wire UI controls
  chEl.querySelector('.ch-vol').addEventListener('input', e=>{
    const v = +e.target.value; channel.gainNode.gain.value = v;
  });
  chEl.querySelector('.ch-pan').addEventListener('input', e=>{
    const p = +e.target.value; channel.panNode.pan.value = p;
  });

  // remove channel
  chEl.querySelector('.remove-ch').addEventListener('click', ()=>{
    // stop recorder if active
    if (channel.recorder && channel.recorder.state !== 'inactive') channel.recorder.stop();
    try{ channel.gainNode.disconnect(); channel.panNode.disconnect(); }catch(_){}
    // remove DOM and state
    chEl.remove();
    state.channels = state.channels.filter(c=> c !== channel);
  });

  // record handlers
  const recBtn = chEl.querySelector('.rec-btn');
  const stopRecBtn = chEl.querySelector('.stop-rec-btn');
  const playLastBtn = chEl.querySelector('.play-last');
  const recordingsEl = chEl.querySelector('.recordings');

  recBtn.addEventListener('click', async ()=>{
    if (audio.ctx.state === 'suspended') await audio.ctx.resume();
    // create MediaRecorder from mediaDest.stream
    const stream = channel.mediaDest.stream;
    const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
    channel.recChunks = [];
    try{
      channel.recorder = new MediaRecorder(stream, {mimeType:mime});
    }catch(err){
      channel.recorder = new MediaRecorder(stream);
    }
    channel.recorder.ondataavailable = e => { if (e.data && e.data.size) channel.recChunks.push(e.data); };
    channel.recorder.onstop = async ()=>{
      const blob = new Blob(channel.recChunks, {type: channel.recorder.mimeType || 'audio/webm'});
      const url = URL.createObjectURL(blob);
      // try to decode to get duration (async)
      let duration = 0;
      try{
        const arr = await blob.arrayBuffer();
        const tmp = await audio.ctx.decodeAudioData(arr.slice(0));
        duration = tmp.duration;
      }catch(_){ duration = 0; }

      const rec = {blob, url, duration};
      channel.recordings.push(rec);
      appendRecordingItem(channel, rec);
      playLastBtn.disabled = false;
      stopRecBtn.disabled = true;
      recBtn.disabled = false;
      recBtn.classList.remove('rec-on');
    };

    channel.recorder.start();
    recBtn.classList.add('rec-on');
    recBtn.disabled = true;
    stopRecBtn.disabled = false;
  });

  stopRecBtn.addEventListener('click', ()=>{
    if (channel.recorder && channel.recorder.state !== 'inactive') channel.recorder.stop();
  });

  playLastBtn.addEventListener('click', async ()=>{
    if (channel.recordings.length === 0) return;
    const last = channel.recordings[channel.recordings.length-1];
    await playBlobThroughCtx(last.blob, channel);
  });

  // save channel in state
  state.channels.push(channel);

  return channel;
}

function appendRecordingItem(channel, rec){
  const list = channel.el.querySelector('.recordings');
  const item = document.createElement('div');
  item.className = 'rec-item';
  item.innerHTML = `
    <div style="flex:1">
      <div class="small">Dur: ${rec.duration?rec.duration.toFixed(2)+'s':'–'}</div>
      <div class="small muted" style="font-size:11px">${new Date().toLocaleString()}</div>
    </div>
    <div style="display:flex;gap:6px;align-items:center">
      <button class="btn-small play-rec">▶</button>
      <a class="btn-small download-rec" href="${rec.url}" download="grabacion_${channel.instId}_${channel.channelId}.webm">⬇</a>
      <button class="btn-small del-rec">✖</button>
    </div>
  `;
  list.appendChild(item);

  const playBtn = item.querySelector('.play-rec');
  const delBtn = item.querySelector('.del-rec');
  const dl = item.querySelector('.download-rec');

  playBtn.addEventListener('click', ()=> playBlobThroughCtx(rec.blob, channel));
  delBtn.addEventListener('click', ()=>{
    // remove from array and DOM
    const idx = channel.recordings.indexOf(rec);
    if (idx >= 0) channel.recordings.splice(idx,1);
    item.remove();
    URL.revokeObjectURL(rec.url);
  });
}

/* ==================== Playback helpers ==================== */
async function playBlobThroughCtx(blob, channel){
  // decode blob to AudioBuffer and play via bufferSource routed through channel nodes
  try{
    const arr = await blob.arrayBuffer();
    const buf = await audio.ctx.decodeAudioData(arr.slice(0));
    const src = audio.ctx.createBufferSource();
    src.buffer = buf;
    // connect to a gain node so it's subject to channel fader/pan
    const tmpGain = audio.ctx.createGain();
    src.connect(tmpGain).connect(channel.gainNode);
    src.start();
    src.onended = ()=> {
      try{ tmpGain.disconnect(); src.disconnect(); }catch(_){}
    };
  }catch(err){
    console.warn('No se pudo reproducir blob:', err);
    // fallback: create audio element and play (bypasses channel fader)
    const url = URL.createObjectURL(blob);
    const a = new Audio(url);
    a.onended = ()=> URL.revokeObjectURL(url);
    a.play();
  }
}

/* ==================== Play / Stop whole mixer ==================== */
const playMixerBtn = document.getElementById('playMixerBtn');
const stopMixerBtn = document.getElementById('stopMixerBtn');
let mixerPlayingHandles = [];

playMixerBtn.addEventListener('click', async ()=>{
  if (audio.ctx.state === 'suspended') await audio.ctx.resume();
  // decode latest recording per channel and start all at t0
  mixerPlayingHandles.forEach(h=>{ try{ h.source.stop(); }catch(_){ }});
  mixerPlayingHandles = [];

  const allDecodes = [];
  for (const instId of Object.keys(audio.instMixers)){
    const state = audio.instMixers[instId];
    for (const ch of state.channels){
      if (ch.recordings.length === 0) continue;
      const last = ch.recordings[ch.recordings.length - 1];
      allDecodes.push({ch, blob: last.blob});
    }
  }

  // decode all
  for (const item of allDecodes){
    try{
      const arr = await item.blob.arrayBuffer();
      const buf = await audio.ctx.decodeAudioData(arr.slice(0));
      const src = audio.ctx.createBufferSource();
      src.buffer = buf;
      const tmpGain = audio.ctx.createGain();
      src.connect(tmpGain).connect(item.ch.gainNode);
      src.start();
      mixerPlayingHandles.push({source:src, tmpGain});
      src.onended = ()=> { try{ tmpGain.disconnect(); src.disconnect(); }catch(_){} };
    }catch(err){
      console.warn('Error decoding for mixer playback', err);
    }
  }
});

stopMixerBtn.addEventListener('click', ()=>{
  for (const h of mixerPlayingHandles){
    try{ h.source.stop(); }catch(_){}
    try{ h.tmpGain.disconnect(); }catch(_){}
  }
  mixerPlayingHandles = [];
});

/* ==================== Export mezcla a MP3 ==================== */
document.getElementById('exportMp3Btn').addEventListener('click', async ()=>{
  // recolectar todos los recordings y sum durations por canal para colocarlos secuencialmente en cada pista
  // calculamos una duración final: la máxima suma de duraciones por canal
  const channelsAll = [];
  for (const instId of Object.keys(audio.instMixers)){
    const state = audio.instMixers[instId];
    for (const ch of state.channels){
      if (ch.recordings.length === 0) continue;
      channelsAll.push(ch);
    }
  }
  if (channelsAll.length === 0){ alert('No hay grabaciones en el mixer para exportar.'); return; }

  // decodificar todas las grabaciones por canal
  // para cada canal, concatenamos sus grabaciones en la pista del bus (emulamos que se tocan en orden una tras otra)
  // determinamos finalLength en segundos
  const decodedPerChannel = []; // {ch, buffers: [AudioBuffer], totalDur}
  let finalSeconds = 0;

  for (const ch of channelsAll){
    const bufs = [];
    let sum = 0;
    for (const rec of ch.recordings){
      try{
        const arr = await rec.blob.arrayBuffer();
        const b = await audio.ctx.decodeAudioData(arr.slice(0));
        bufs.push(b);
        sum += b.duration;
      }catch(err){
        console.warn('decode err', err);
      }
    }
    decodedPerChannel.push({ch, buffers:bufs, totalDur:sum});
    if (sum > finalSeconds) finalSeconds = sum;
  }

  // final length: max channel total
  if (finalSeconds <= 0) { alert('No se pudo determinar duración de las grabaciones.'); return; }
  const sampleRate = 44100;
  const offline = new OfflineAudioContext(2, Math.ceil(finalSeconds * sampleRate), sampleRate);

  // para cada channel, crear un bus (gain + pan) y conectar a offline.destination
  for (const item of decodedPerChannel){
    const g = offline.createGain(); g.gain.value = item.ch.gainNode.gain.value;
    const p = offline.createStereoPanner(); p.pan.value = item.ch.panNode.pan.value;
    g.connect(p).connect(offline.destination);

    // por cada buffer en orden, crear buffer source y ubicarlo en la timeline acumulativa
    let offset = 0;
    for (const b of item.buffers){
      const src = offline.createBufferSource();
      // copiar channels
      const clone = offline.createBuffer(b.numberOfChannels, b.length, b.sampleRate);
      for (let c=0;c<b.numberOfChannels;c++) clone.copyToChannel(b.getChannelData(c), c);
      src.buffer = clone;
      src.connect(g);
      src.start(offset);
      offset += b.duration;
    }
  }

  // render offline
  try{
    const rendered = await offline.startRendering();
    const mp3bytes = wavToMp3(rendered);
    const blob = new Blob([new Uint8Array(mp3bytes)], {type:'audio/mpeg'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'mezcla.mp3';
    a.click();
    URL.revokeObjectURL(url);
  }catch(err){
    console.error('Error al renderizar offline', err);
    alert('Error al exportar: ' + err.message);
  }
});

// convierte AudioBuffer a mp3 con lamejs
function wavToMp3(abuf){
  const numCh = 2, sr = abuf.sampleRate;
  const ch0 = abuf.getChannelData(0);
  const ch1 = (abuf.numberOfChannels>1)?abuf.getChannelData(1):ch0;
  const enc = new lamejs.Mp3Encoder(numCh, sr, 192);
  const block = 1152;
  const out = [];
  function f2i16(f){ const s = Math.max(-1, Math.min(1, f)); return s<0 ? Math.round(s*0x8000) : Math.round(s*0x7FFF); }
  for (let i=0; i<ch0.length; i+=block){
    const l = ch0.subarray(i, i+block), r = ch1.subarray(i, i+block);
    const L = new Int16Array(l.length), R = new Int16Array(r.length);
    for (let k=0;k<l.length;k++){ L[k]=f2i16(l[k]); R[k]=f2i16(r[k]); }
    const part = enc.encodeBuffer(L,R); if (part.length) out.push(part);
  }
  const flush = enc.flush(); if (flush.length) out.push(flush);
  return out.reduce((acc,chunk)=> new Uint8Array([...acc,...chunk]), new Uint8Array());
}

/* ============== Instrument windows: abrir ventana y crear canal ============== */
let currentInstWin = null;
function openInstrument(instId){
  const inst = audio.instruments[instId];
  if (!inst) return;
  if (currentInstWin) currentInstWin.remove();
  const win = document.createElement('div');
  win.style.position='fixed';
  win.style.top='120px';
  win.style.left='120px';
  win.style.width='420px';
  win.style.borderRadius='12px';
  win.style.overflow='hidden';
  win.style.border='1px solid #264562';
  win.style.background='#0d1218';
  win.style.boxShadow='0 20px 60px rgba(0,0,0,.5)';
  win.style.zIndex='60';
  win.innerHTML = `
    <div style="display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:rgba(0,0,0,.35);border-bottom:1px solid #1b2b3c;cursor:move;">
      <div style="font-weight:700">${inst.name}</div>
      <div style="display:flex;gap:8px">
        <button class="btn-small create-channel">➕ Crear canal</button>
        <button class="btn-small close-win">✕</button>
      </div>
    </div>
    <div style="padding:12px; display:flex; gap:10px; flex-wrap:wrap;">
      <div style="flex:1">
        <div class="small muted">Gain</div>
        <input type="range" min="0" max="1" step="0.01" value="${inst.gain}" data-k="gain" style="width:100%">
      </div>
      <div style="flex:1">
        <div class="small muted">Cutoff</div>
        <input type="range" min="100" max="12000" step="1" value="${inst.cutoff}" data-k="cutoff" style="width:100%">
      </div>
    </div>
    <div style="padding:0 12px 12px 12px" class="kbdhint">Toca con tu dispositivo o usa samples predefinidos. Usa "Crear canal" para crear un canal en el Mixer.</div>
  `;
  document.body.appendChild(win);
  currentInstWin = win;

  // handlers
  win.querySelector('.close-win').onclick = ()=> { win.remove(); currentInstWin=null; };
  win.querySelector('.create-channel').addEventListener('click', ()=>{
    makeInstMixer(instId); // ensure inst mixer exists
    createChannelForInstrument(instId);
  });
  // small knobs in window affect default instrument settings
  win.querySelectorAll('input[type="range"]').forEach(r=>{
    r.addEventListener('input', e=>{
      const k = e.target.dataset.k; const v = parseFloat(e.target.value);
      if (k === 'gain'){ inst.gain = v; }
      if (k === 'cutoff'){ inst.cutoff = v; }
    });
  });

  // allow dragging of window
  const header = win.firstElementChild;
  let dragging = false, offX=0, offY=0;
  header.addEventListener('mousedown', e=>{ dragging=true; offX=e.clientX - win.offsetLeft; offY=e.clientY - win.offsetTop; document.body.style.userSelect='none'; });
  document.addEventListener('mousemove', e=>{ if(!dragging) return; let x = e.clientX-offX, y = e.clientY-offY; x=Math.max(8, Math.min(x, window.innerWidth-win.offsetWidth-8)); y=Math.max(8, Math.min(y, window.innerHeight-win.offsetHeight-8)); win.style.left=x+'px'; win.style.top=y+'px'; });
  document.addEventListener('mouseup', ()=>{ dragging=false; document.body.style.userSelect=''; });
}

/* ============== Attach instrument buttons ============== */
document.querySelectorAll('.inst-btn').forEach(btn=>{
  btn.addEventListener('click', ()=> {
    const id = parseInt(btn.dataset.id,10);
    makeInstMixer(id); // create mixer block
    openInstrument(id);
  });
});

/* ================= Quick demo: create mixer area if instrument created externally ================= */
 // nothing more; user triggers by clicking instrument
</script>
</body>
</html>
