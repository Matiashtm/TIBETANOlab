<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<title>TIBETANOlab - Caja de Ritmos + Melódicos (Mini DAW)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
:root{
  --bg:#071018; --panel:#0f1820; --accent:#6b9cff; --text:#e8eef5; --muted:#9fb4c8;
  --ok:#2ecc71; --danger:#ff5a5f; --radius:12px;
}
*{box-sizing:border-box}
body{margin:0;background:linear-gradient(180deg,#071018,#08121a);color:var(--text);font-family:Inter,Segoe UI,Roboto,Arial;height:100vh;display:flex;flex-direction:column}
header{display:flex;align-items:center;padding:10px 14px;gap:8px;background:rgba(255,255,255,0.02);border-bottom:1px solid rgba(255,255,255,0.03)}
.brand{font-weight:700}
.buttons{margin-left:auto;display:flex;gap:8px;flex-wrap:wrap}
.btn{padding:8px 12px;border-radius:10px;background:#0c1620;border:1px solid #18324a;color:var(--text);cursor:pointer}
.btn[disabled]{opacity:0.6;cursor:not-allowed}
.btn.small{padding:6px 10px;font-size:12px}
.btn.toggle.on{border-color:var(--ok);color:var(--ok)}
.main{flex:1;display:grid;grid-template-columns:300px 1fr;gap:12px;padding:12px;align-items:stretch;min-height:0}
.left{background:var(--panel);padding:12px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.03);overflow:auto}
.left h3{margin:10px 0 8px 0;color:var(--muted);font-size:13px}
.row-btn{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:10px;background:#08121a;border:1px dashed rgba(255,255,255,0.02);margin-bottom:8px;cursor:pointer}
.row-btn:hover{border-style:solid;border-color:#234a76}
.center{display:flex;flex-direction:column;gap:10px;min-width:0}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.chips{display:flex;gap:6px}
.chip{padding:6px 10px;border-radius:10px;background:#0d1620;border:1px solid #213b53;cursor:pointer;color:var(--muted)}
.chip.active{background:rgba(107,156,255,0.12);border-color:var(--accent);color:#dfeeff}
.playbtn{padding:8px 12px;border-radius:10px;background:#0f1720;border:1px solid #23455f;cursor:pointer}
.playbtn.playing{border-color:var(--ok);color:var(--ok)}
.rollwrap{background:var(--panel);padding:10px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.03);display:flex;flex-direction:column;gap:8px;min-height:0}
.rollArea{position:relative;height:360px;border-radius:8px;overflow:auto;background:#071219;border:1px solid #172735}
canvas{display:block}
.keysCanvas{position:absolute;left:0;top:0;z-index:10;background:rgba(0,0,0,0.03)}
.notesCanvas{position:absolute;left:0;top:0;z-index:20}
.hint{font-size:12px;color:var(--muted)}
.mixer{background:var(--panel);padding:10px;border-radius:var(--radius);border:1px solid rgba(255,255,255,0.03);display:flex;gap:10px;overflow:auto;min-height:150px}
.strip{min-width:190px;background:#0b1419;padding:10px;border-radius:10px;border:1px solid #183248;display:flex;flex-direction:column;gap:8px}
.strip h4{margin:0 0 4px 0}
.small{font-size:12px;color:var(--muted)}
.fader{width:100%}
.clipList{display:flex;flex-direction:column;gap:6px}
.clipItem{display:flex;align-items:center;gap:6px;background:#0b1117;border:1px solid #173046;padding:6px;border-radius:8px}
.inst-win{position:fixed;width:420px;border-radius:12px;overflow:hidden;background:#071219;border:1px solid #1f3245;box-shadow:0 20px 60px rgba(0,0,0,0.6);z-index:60}
.inst-title{display:flex;align-items:center;justify-content:space-between;padding:10px;background:rgba(255,255,255,0.02);cursor:move}
.inst-bg{height:180px;background:#0b1115;background-size:cover;background-position:center}
.inst-ctrls{display:flex;gap:8px;padding:10px;flex-wrap:wrap}
.knob{flex:1 1 120px;background:#0c1620;padding:8px;border-radius:8px;border:1px solid #162b3f}
.knob label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
.kbdhint{padding:8px;font-size:12px;color:var(--muted)}
.sectionTitle{margin:0 0 6px 0;color:#cfe2ff}
.left .group{margin-bottom:16px}
kbd{background:#0e1722;border:1px solid #1c3348;padding:2px 6px;border-radius:6px;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
</style>
</head>
<body>

<header>
  <div class="brand">TIBETANOlab — Melódicos + Caja de Ritmos</div>
  <div class="buttons">
    <button id="masterPlayBtn" class="btn playbtn">▶ Play Master</button>
    <button id="masterLoopBtn" class="btn">Loop: ON</button>
    <button id="masterRecBtn" class="btn">● Grabar Master (WAV)</button>
    <button id="clearDrumsBtn" class="btn">Limpiar Percusión</button>
  </div>
</header>

<div class="main">
  <!-- LEFT -->
  <aside class="left" id="left">
    <div class="group">
      <h3 class="sectionTitle">Instrumentos Melódicos (en vivo)</h3>
      <div id="melodicList"></div>
      <div class="small">Haz click en un instrumento para abrir su ventana, tocarlo y <b>Crear Canal</b> en el mixer.</div>
      <div class="small" style="margin-top:6px">Atajos: teclado de PC fila <kbd>ASDF...</kbd> = notas blancas, <kbd>WET...</kbd> = negras.</div>
    </div>
    <div class="group">
      <h3 class="sectionTitle">Percusión (para caja de ritmos)</h3>
      <div id="percList"></div>
      <div class="small">Puedes abrir la ventana para crear el canal y ajustar nivel/pan. Los bloques se programan a la derecha.</div>
    </div>
  </aside>

  <!-- CENTER -->
  <section class="center">
    <div class="controls">
      <div class="chips" id="gridChips"></div>
      <div class="small" style="margin-left:12px">Tempo <input id="tempo" type="number" value="100" min="40" max="220" style="width:80px;margin-left:6px"></div>
      <div class="small" style="margin-left:12px">Compases <input id="bars" type="number" value="4" min="1" max="64" style="width:60px;margin-left:6px"></div>
      <div class="small" style="margin-left:12px">Zoom <input id="zoom" type="range" min="40" max="180" value="80"></div>
      <div style="margin-left:auto" class="small">Click: crear · Arrastrar: mover/estirar · Click derecho: borrar</div>
    </div>

    <div class="rollwrap">
      <div class="rollArea" id="rollArea">
        <canvas id="keysCanvas" class="keysCanvas"></canvas>
        <canvas id="notesCanvas" class="notesCanvas"></canvas>
      </div>
      <div class="hint">Cada fila es un sample de percusión (WAV). Los canales se crean automáticamente cuando programas un bloque (o desde su ventana).</div>
    </div>

    <div class="mixer" id="mixer"></div>
  </section>
</div>

<script>
/* =========================
   GLOBALES (declaradas primero)
   ========================= */
let currentMelodicWin = null;
let currentPercWin = null;

const transport = {
  tempo: 100,
  bars: 4,
  loop: true,
  playing: false,
  startTime: 0,     // AudioContext time cuando arranca el ciclo
  rafId: 0,
  loopLenSec(){ return this.bars * 4 * (60/this.tempo); }
};

const audio = {
  ctx: new (window.AudioContext || window.webkitAudioContext)(),
  master: null,
  mediaDest: null,  // para previsualización/MediaStream si hiciera falta
  buffers: {},      // id -> AudioBuffer
  mixer: {},        // id -> {gainNode, panNode, el, clips:[], armedRec:boolean, workRec?}
  liveHandles: new Set(),
  init(){
    this.master = this.ctx.createGain(); this.master.gain.value = 1;
    const pan = this.ctx.createStereoPanner();
    this.master.connect(pan).connect(this.ctx.destination);

    // rama para master recording via AudioWorklet
    this.masterRecorder = createWorkletRecorder(this.ctx);
    this.master.connect(this.masterRecorder.node);
    this.masterRecorder.node.connect(this.ctx.destination); // monitoreo
  },
  async loadBuffer(key, url){
    if (this.buffers[key]) return this.buffers[key];
    const res = await fetch(url);
    if (!res.ok) throw new Error('HTTP '+res.status+' '+url);
    const ab = await res.arrayBuffer();
    const buf = await this.ctx.decodeAudioData(ab);
    this.buffers[key] = buf;
    return buf;
  },
  noteOnBuffer({key, when=0, playbackRate=1, dest}){
    const buf = this.buffers[key];
    if (!buf) return null;
    const ctx = this.ctx;
    const src = ctx.createBufferSource(); src.buffer = buf; src.playbackRate.value = playbackRate || 1;
    const amp = ctx.createGain(); amp.gain.value = 1;
    const filt = ctx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value = 20000;
    const out = dest || this.mixer[key]?.gainNode || this.master;
    src.connect(filt).connect(amp).connect(out);

    const handle = {source:src, amp, start:ctx.currentTime + when};
    src.onended = ()=>{ try{src.disconnect();}catch{} try{filt.disconnect();}catch{} try{amp.disconnect();}catch{} this.liveHandles.delete(handle); };
    src.start(ctx.currentTime + when);
    this.liveHandles.add(handle);
    return handle;
  },
  stopAll(){
    for (const h of Array.from(this.liveHandles)){
      try{ h.source.stop(); }catch{}
    }
    this.liveHandles.clear();
  }
};
audio.init();

/* =========================
   DATOS: Percusión (del código 2) y Melódicos
   ========================= */
const percRows = [
  {id:'conga',   name:'Conga',   wav:'samples/conga.wav',   img:'imgs/conga.png'},
  {id:'guiro',   name:'Guiro',   wav:'samples/guiro.wav',   img:'imgs/guiro.png'},
  {id:'timbal',  name:'Timbal',  wav:'samples/timbal.wav',  img:'imgs/timbal.png'},
  {id:'kick',    name:'Kick',    wav:'samples/kick.wav',    img:'imgs/kick.png'},
  {id:'snare',   name:'Snare',   wav:'samples/snare.wav',   img:'imgs/snare.png'},
  {id:'hihat',   name:'HiHat',   wav:'samples/hihat.wav',   img:'imgs/hihat.png'},
  {id:'clap',    name:'Clap',    wav:'samples/clap.wav',    img:'imgs/clap.png'},
  {id:'cowbell', name:'Cowbell', wav:'samples/cowbell.wav', img:'imgs/cowbell.png'},
  {id:'shaker',  name:'Shaker',  wav:'samples/shaker.wav',  img:'imgs/shaker.png'},
  {id:'tom',     name:'Tom',     wav:'samples/tom.wav',     img:'imgs/tom.png'}
];

/* Si en tu Código 1 tenías otra lista/rutas, reemplaza este arreglo por el tuyo.
   Usamos el mismo patrón de rutas WAV/IMG para que "caiga parado" */
const melodicRows = [
  {id:'piano',     name:'Piano',      wav:'samples/piano.wav',      img:'imgs/piano.png'},
  {id:'epiano',    name:'EPiano',     wav:'samples/epiano.wav',     img:'imgs/epiano.png'},
  {id:'organ',     name:'Organ',      wav:'samples/organ.wav',      img:'imgs/organ.png'},
  {id:'bass',      name:'Bass',       wav:'samples/bass.wav',       img:'imgs/bass.png'},
  {id:'guitar',    name:'Guitar',     wav:'samples/guitar.wav',     img:'imgs/guitar.png'},
  {id:'pad',       name:'Pad',        wav:'samples/pad.wav',        img:'imgs/pad.png'},
  {id:'lead',      name:'Lead',       wav:'samples/lead.wav',       img:'imgs/lead.png'},
  {id:'strings',   name:'Strings',    wav:'samples/strings.wav',    img:'imgs/strings.png'},
  {id:'brass',     name:'Brass',      wav:'samples/brass.wav',      img:'imgs/brass.png'},
  {id:'flute',     name:'Flute',      wav:'samples/flute.wav',      img:'imgs/flute.png'}
];

/* =========================
   UI — Listas izquierda
   ========================= */
const melodicList = document.getElementById('melodicList');
const percList    = document.getElementById('percList');

melodicRows.forEach(row=>{
  const btn = document.createElement('div');
  btn.className = 'row-btn';
  btn.innerHTML = `<div>${row.name}</div><div class="small">${row.id}</div>`;
  btn.onclick = ()=> openMelodicWindow(row);
  melodicList.appendChild(btn);
});

percRows.forEach(row=>{
  const btn = document.createElement('div');
  btn.className = 'row-btn';
  btn.innerHTML = `<div>${row.name}</div><div class="small">${row.id}</div>`;
  btn.onclick = ()=> openPercWindow(row);
  percList.appendChild(btn);
});

/* =========================
   Piano-roll percusión
   ========================= */
const notesCanvas = document.getElementById('notesCanvas');
const keysCanvas  = document.getElementById('keysCanvas');
const rollArea = document.getElementById('rollArea');

const roll = {
  rows: percRows.length,
  rowH: 34,
  keyLaneW: 160,
  pxPerBeat: 80,
  quant: 1/4,
  notes: [], // {x,len,rowId}
  dragging: null
};

function beatsToPx(b){ return b * roll.pxPerBeat; }
function pxToBeats(px){ return px / roll.pxPerBeat; }
function quantize(b){ const q = roll.quant; return Math.round(b/q)*q; }

function resizeCanvas(){
  const beats = transport.bars*4;
  const w = roll.keyLaneW + Math.max(900, Math.ceil(roll.pxPerBeat*beats));
  const h = roll.rows * roll.rowH;
  notesCanvas.width = w; notesCanvas.height = h;
  keysCanvas.width = roll.keyLaneW; keysCanvas.height = h;
  notesCanvas.style.left = '0px'; notesCanvas.style.top = '0px';
  keysCanvas.style.left = '0px'; keysCanvas.style.top = '0px';
  rollArea.scrollLeft = 0;
  drawAll();
}

function drawKeys(){
  const kctx = keysCanvas.getContext('2d');
  kctx.clearRect(0,0,keysCanvas.width,keysCanvas.height);
  kctx.fillStyle='#0a141c';
  kctx.fillRect(0,0,keysCanvas.width,keysCanvas.height);
  for (let i=0;i<roll.rows;i++){
    const y = i*roll.rowH;
    kctx.fillStyle = (i%2===0)?'#07121a':'#07151c';
    kctx.fillRect(0,y,keysCanvas.width,roll.rowH);
    kctx.strokeStyle='#0e2432';
    kctx.beginPath(); kctx.moveTo(0,y+0.5); kctx.lineTo(keysCanvas.width,y+0.5); kctx.stroke();

    const row = percRows[i];
    kctx.fillStyle='#dfeeff';
    kctx.font='13px sans-serif';
    kctx.fillText(row.name, 10, y + 20);
    kctx.fillStyle='#98b9d2';
    kctx.font='11px sans-serif';
    kctx.fillText(row.id, 10, y + 32);
  }
}

function drawNotes(){
  const ctx = notesCanvas.getContext('2d');
  ctx.clearRect(0,0,notesCanvas.width,notesCanvas.height);

  const beats = transport.bars*4;

  // vertical grid
  for (let b=0;b<=beats;b+=roll.quant){
    const x = roll.keyLaneW + beatsToPx(b);
    const isBar = Math.abs(b-Math.round(b))<1e-6;
    ctx.strokeStyle = isBar?'#183044':'#0f2a3b';
    ctx.lineWidth = isBar?1.2:1;
    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,notesCanvas.height); ctx.stroke();
  }

  // notes
  for (const n of roll.notes){
    const rowIdx = percRows.findIndex(r=>r.id===n.rowId);
    if (rowIdx < 0) continue;
    const y = rowIdx * roll.rowH + 6;
    const x = roll.keyLaneW + beatsToPx(n.x);
    const w = Math.max(6, Math.floor(beatsToPx(n.len)));
    const h = roll.rowH - 12;
    const hue = (rowIdx * 78) % 360;
    ctx.fillStyle = `hsl(${hue} 70% 55% / 0.95)`;
    ctx.fillRect(x, y, w, h);
    ctx.strokeStyle = `hsl(${hue} 80% 35%)`;
    ctx.strokeRect(x+0.5, y+0.5, w, h);
    // resize handle
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(x + w - 6, y, 6, h);
  }

  // playhead
  if (transport.playing){
    const elapsed = audio.ctx.currentTime - transport.startTime;
    const playbeat = elapsed / (60/transport.tempo);
    const x = roll.keyLaneW + beatsToPx(playbeat % (transport.bars*4));
    ctx.strokeStyle = '#ff4d4f'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x+0.5,0); ctx.lineTo(x+0.5,notesCanvas.height); ctx.stroke();
    transport.rafId = requestAnimationFrame(drawNotes);
  }
}

function drawAll(){ drawKeys(); drawNotes(); }
resizeCanvas();

/* hit test */
function hitNoteAt(mx,my){
  for (let i=roll.notes.length-1;i>=0;i--){
    const n = roll.notes[i];
    const rowIdx = percRows.findIndex(r=>r.id===n.rowId);
    if (rowIdx<0) continue;
    const x = roll.keyLaneW + beatsToPx(n.x);
    const w = beatsToPx(n.len);
    const y = rowIdx * roll.rowH + 6;
    const h = roll.rowH - 12;
    if (mx>=x && mx<=x+w && my>=y && my<=y+h){
      return {note:n, index:i, x,y,w,h};
    }
  }
  return null;
}

/* mouse events */
notesCanvas.addEventListener('mousedown', async (e)=>{
  if (e.button===2) return; // right-click borrar
  const rect = notesCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const b = pxToBeats(Math.max(0, mx - roll.keyLaneW));
  const row = Math.floor(my / roll.rowH);
  const hit = hitNoteAt(mx,my);
  if (hit){
    const nearRight = (mx >= hit.x + hit.w - 6);
    if (nearRight){
      roll.dragging = {type:'resize', note:hit.note, index:hit.index};
    } else {
      roll.dragging = {type:'move', note:hit.note, index:hit.index, offBeat: b - hit.note.x, offRow: row - percRows.findIndex(r=>r.id===hit.note.rowId)};
    }
    return;
  }
  // crear nueva nota
  const rowId = percRows[Math.max(0, Math.min(roll.rows-1,row))].id;
  const xBeat = quantize(b);
  const newNote = {x:xBeat, len: roll.quant, rowId};
  roll.notes.push(newNote);
  // auto-crear canal si no existe
  ensureMixerChannel(rowId, findById(rowId).name);
  await loadIfNeeded(rowId);
  drawAll();
});

notesCanvas.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const rect = notesCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left; const my = e.clientY - rect.top;
  const hit = hitNoteAt(mx,my);
  if (hit) {
    roll.notes.splice(hit.index,1);
    drawAll();
    maybeRemoveMixerIfUnused(hit.note.rowId);
  }
});

window.addEventListener('mousemove', (e)=>{
  if (!roll.dragging) return;
  const rect = notesCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const b = pxToBeats(Math.max(0, mx - roll.keyLaneW));
  const rowIdx = Math.floor(my/roll.rowH);
  const r = Math.max(0, Math.min(roll.rows-1, rowIdx));
  const n = roll.dragging.note;
  if (roll.dragging.type === 'move'){
    n.x = Math.max(0, quantize(b - roll.dragging.offBeat));
    n.rowId = percRows[Math.max(0,Math.min(roll.rows-1, r - roll.dragging.offRow))].id;
  } else {
    n.len = Math.max(roll.quant, quantize(b - n.x));
  }
  drawAll();
});
window.addEventListener('mouseup', ()=>{ roll.dragging = null; });

/* grid chips */
const gridList = [1,0.5,0.25,0.125,0.0625,0.03125];
const gridChips = document.getElementById('gridChips');
gridList.forEach(g=>{
  const el = document.createElement('div'); el.className='chip' + (g===roll.quant?' active':'');
  el.textContent = (g===1)?'1/1':(g===0.5)?'1/2':'1/'+(1/g);
  el.onclick = ()=> { roll.quant=g; [...gridChips.children].forEach(c=>c.classList.remove('active')); el.classList.add('active'); drawAll(); };
  gridChips.appendChild(el);
});

/* tempo / bars / zoom */
document.getElementById('tempo').addEventListener('input', (e)=> transport.tempo = Math.max(40, Math.min(220, +e.target.value||100)));
document.getElementById('bars').addEventListener('input', (e)=> { transport.bars = Math.max(1, Math.min(64, +e.target.value||4)); resizeCanvas(); });
document.getElementById('zoom').addEventListener('input', (e)=> { roll.pxPerBeat = +e.target.value; resizeCanvas(); });

/* =========================
   Programación y transporte
   ========================= */
function scheduleOneLoop(startAt){
  const spb = 60/transport.tempo;
  const now = audio.ctx.currentTime;

  // Percusión
  for (const n of roll.notes){
    const when = startAt + (n.x * spb);
    audio.noteOnBuffer({key:n.rowId, when:(when - now)});
  }

  // Clips grabados por canal (melódicos y percusivos)
  const loopLen = transport.loopLenSec();
  for (const [key, ch] of Object.entries(audio.mixer)){
    if (!ch.clips || !ch.clips.length) continue;
    for (const clip of ch.clips){
      if (!clip.play) continue;
      // reproducir el buffer del clip alineado al inicio del loop
      const src = audio.ctx.createBufferSource();
      src.buffer = clip.buffer;
      src.loop = clip.loop;
      src.connect(ch.gainNode);
      try{ src.start(startAt); }catch(e){/* si ya pasó, ignorar */}
      // guardar para poder parar al detener master
      ch._playing = ch._playing || [];
      ch._playing.push(src);
      src.onended = ()=>{ ch._playing = (ch._playing||[]).filter(s=>s!==src); try{src.disconnect();}catch{} };
    }
  }

  // reprogramar siguiente vuelta si loop
  if (transport.loop){
    const ms = Math.max(0, (startAt + loopLen - audio.ctx.currentTime) * 1000 - 60);
    transport._timer = setTimeout(()=> scheduleOneLoop(startAt + loopLen), ms);
  } else {
    // sin loop: parar al final
    clearTimeout(transport._timer);
    transport._timer = setTimeout(()=> masterStop(), (loopLen*1000)+200);
  }
}

function masterPlay(){
  if (audio.ctx.state==='suspended') audio.ctx.resume();
  // precargar buffers usados (percusión + cualquier canal creado)
  const usedPerc = [...new Set(roll.notes.map(n=>n.rowId))];
  const usedKeys = new Set(usedPerc);
  for (const k of Object.keys(audio.mixer)) usedKeys.add(k);
  Promise.all([...usedKeys].map(k=>loadIfNeeded(k))).then(()=>{
    transport.playing = true;
    transport.startTime = audio.ctx.currentTime + 0.05;
    document.getElementById('masterPlayBtn').classList.add('playing');
    document.getElementById('masterPlayBtn').textContent='⏹ Stop Master';
    scheduleOneLoop(transport.startTime);
    transport.rafId = requestAnimationFrame(drawNotes);
  });
}

function masterStop(){
  transport.playing = false;
  clearTimeout(transport._timer);
  cancelAnimationFrame(transport.rafId);
  audio.stopAll();
  // parar clips por canal
  for (const ch of Object.values(audio.mixer)){
    if (ch._playing){
      for (const s of ch._playing) { try{s.stop();}catch{} }
      ch._playing = [];
    }
  }
  document.getElementById('masterPlayBtn').classList.remove('playing');
  document.getElementById('masterPlayBtn').textContent='▶ Play Master';
  drawAll();
}

/* Master botones */
document.getElementById('masterPlayBtn').onclick = ()=> transport.playing? masterStop() : masterPlay();
document.getElementById('masterLoopBtn').onclick = (e)=>{ transport.loop = !transport.loop; e.target.textContent = 'Loop: ' + (transport.loop? 'ON':'OFF'); };
document.getElementById('clearDrumsBtn').onclick = ()=>{ roll.notes=[]; drawAll(); for (const p of percRows) maybeRemoveMixerIfUnused(p.id); };

/* =========================
   Ventanas: Melódicos y Percusión
   ========================= */
function openMelodicWindow(row){
  // única ventana
  if (currentMelodicWin) currentMelodicWin.remove();
  const win = document.createElement('div'); win.className='inst-win'; win.style.left='90px'; win.style.top='80px';
  win.innerHTML = `
    <div class="inst-title"><div style="font-weight:700">${row.name}</div><div style="display:flex;gap:8px">
      <button class="btn small" id="createChannel">Crear Canal</button>
      <div class="btn small" id="closeWin">✕</div>
    </div></div>
    <div class="inst-bg" style="background-image:url('${row.img || ''}');"></div>
    <div class="inst-ctrls">
      <div class="knob"><label>Gain</label><input type="range" min="0" max="2" step="0.01" value="1" data-k="gain"></div>
      <div class="knob"><label>Cutoff</label><input type="range" min="200" max="20000" step="1" value="20000" data-k="cutoff"></div>
      <div class="knob"><label>Pitch (semitonos)</label><input type="range" min="-24" max="24" step="1" value="0" data-k="pitch"></div>
      <div class="knob"><label>Trigger</label><button class="btn small" id="trigBtn">●</button></div>
    </div>
    <div class="kbdhint">Usa teclado PC: <kbd>ASDFGHJ</kbd> (blancas) y <kbd>WETYU</kbd> (negras). Toca y luego <b>Grabar</b> en el canal.</div>
  `;
  document.body.appendChild(win);
  currentMelodicWin = win;

  // drag
  const header = win.querySelector('.inst-title');
  let dragging=false, ox=0, oy=0;
  header.addEventListener('mousedown', (e)=>{ dragging=true; ox=e.clientX-win.offsetLeft; oy=e.clientY-win.offsetTop; document.body.style.userSelect='none'; });
  document.addEventListener('mousemove', (e)=>{ if(!dragging) return; win.style.left = (e.clientX-ox)+'px'; win.style.top = (e.clientY-oy)+'px'; });
  document.addEventListener('mouseup', ()=>{ dragging=false; document.body.style.userSelect=''; });

  win.querySelector('#closeWin').onclick = ()=>{ win.remove(); currentMelodicWin=null; };

  // Crear canal
  win.querySelector('#createChannel').onclick = async ()=>{
    ensureMixerChannel(row.id, row.name);
    await loadIfNeeded(row.id, row.wav);
  };

  // controles y tocar
  let pitch = 0;
  win.querySelector('[data-k="pitch"]').addEventListener('input', (e)=> pitch = +e.target.value|0);
  win.querySelector('#trigBtn').onclick = ()=> triggerMelodic(row.id, 60+pitch);

  // teclado PC
  const keyMap = {
    // blancas
    'a':0, 's':2, 'd':4, 'f':5, 'g':7, 'h':9, 'j':11, 'k':12,
    // negras
    'w':1, 'e':3, 't':6, 'y':8, 'u':10
  };
  const onKeyDown = (ev)=>{
    const k = ev.key.toLowerCase();
    if (keyMap[k]!==undefined){
      triggerMelodic(row.id, 60 + keyMap[k] + pitch);
      ev.preventDefault();
    }
  };
  window.addEventListener('keydown', onKeyDown);
  win.addEventListener('remove', ()=> window.removeEventListener('keydown', onKeyDown));
}

function openPercWindow(row){
  // única ventana perc
  if (currentPercWin) currentPercWin.remove();
  const win = document.createElement('div'); win.className='inst-win'; win.style.left='540px'; win.style.top='80px';
  win.innerHTML = `
    <div class="inst-title"><div style="font-weight:700">${row.name}</div><div style="display:flex;gap:8px">
      <button class="btn small" id="createChannel">Crear Canal</button>
      <div class="btn small" id="closeWin">✕</div>
    </div></div>
    <div class="inst-bg" style="background-image:url('${row.img || ''}');"></div>
    <div class="inst-ctrls">
      <div class="knob"><label>Gain</label><input type="range" min="0" max="2" step="0.01" value="1" data-k="gain"></div>
      <div class="knob"><label>Pan</label><input type="range" min="-1" max="1" step="0.01" value="0" data-k="pan"></div>
      <div class="knob"><label>Trigger</label><button class="btn small" id="trigBtn">●</button></div>
    </div>
    <div class="kbdhint">Crea canal para controlar nivel/pan y grabar tomas del instrumento si quieres.</div>
  `;
  document.body.appendChild(win);
  currentPercWin = win;

  win.querySelector('#closeWin').onclick = ()=>{ win.remove(); currentPercWin=null; };

  // Crear canal
  win.querySelector('#createChannel').onclick = async ()=>{
    ensureMixerChannel(row.id, row.name);
    await loadIfNeeded(row.id, row.wav);
  };

  win.querySelector('#trigBtn').onclick = ()=> triggerPerc(row.id);
}

/* =========================
   Cargar buffers util
   ========================= */
function findById(id){
  return percRows.find(r=>r.id===id) || melodicRows.find(r=>r.id===id);
}
async function loadIfNeeded(id, overrideUrl){
  const row = findById(id);
  if (!row) return;
  const url = overrideUrl || row.wav;
  try{ await audio.loadBuffer(id, url); }catch(e){ console.warn('No pudo cargar',url,e); }
}

/* =========================
   Disparo Melódico (pitch shifting)
   ========================= */
function triggerMelodic(id, midi=60){
  const baseMidi = 60; // C4 base
  const semitones = midi - baseMidi;
  const rate = Math.pow(2, semitones/12);
  ensureMixerChannel(id, findById(id)?.name || id);
  loadIfNeeded(id).then(()=>{
    audio.noteOnBuffer({key:id, playbackRate: rate});
  });
}

/* =========================
   Disparo Percusión
   ========================= */
function triggerPerc(id){
  ensureMixerChannel(id, findById(id)?.name || id);
  loadIfNeeded(id).then(()=>{
    audio.noteOnBuffer({key:id});
  });
}

/* =========================
   MIXER
   ========================= */
const mixerEl = document.getElementById('mixer');

function ensureMixerChannel(id, name){
  if (audio.mixer[id]) return audio.mixer[id];
  // UI strip
  const strip = document.createElement('div'); strip.className='strip';
  strip.innerHTML = `
    <h4>${name}</h4>
    <div class="small">Volumen</div>
    <input class="fader" type="range" min="0" max="2" step="0.01" value="1" data-vol>
    <div class="small">Pan</div>
    <input class="fader" type="range" min="-1" max="1" step="0.01" value="0" data-pan>
    <div class="small">Clips grabados</div>
    <div class="clipList" data-clips></div>
    <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap">
      <button class="btn small" data-rec>● Grabar Canal</button>
      <button class="btn small" data-del>Eliminar Canal</button>
      <button class="btn small" data-solo>Solo</button>
      <button class="btn small" data-mute>Mute</button>
    </div>
  `;
  mixerEl.appendChild(strip);

  // nodos
  const gainNode = audio.ctx.createGain(); gainNode.gain.value = 1;
  const panNode = audio.ctx.createStereoPanner(); panNode.pan.value = 0;
  gainNode.connect(panNode).connect(audio.master);

  const ch = audio.mixer[id] = {
    id, name, el:strip, gainNode, panNode,
    clips:[], rec:null, solo:false, mute:false
  };

  // controles
  strip.querySelector('[data-vol]').addEventListener('input', (e)=>{ gainNode.gain.value = ch.mute ? 0 : +e.target.value; });
  strip.querySelector('[data-pan]').addEventListener('input', (e)=>{ panNode.pan.value = +e.target.value; });

  // Solo/Mute simples
  strip.querySelector('[data-solo]').onclick = (e)=>{
    ch.solo = !ch.solo; e.target.classList.toggle('toggle','on');
    applySoloMute();
  };
  strip.querySelector('[data-mute]').onclick = (e)=>{
    ch.mute = !ch.mute; e.target.classList.toggle('toggle','on');
    applySoloMute();
  };

  function applySoloMute(){
    const anySolo = Object.values(audio.mixer).some(m=>m.solo);
    for (const m of Object.values(audio.mixer)){
      const volCtrl = m.el.querySelector('[data-vol]');
      const base = +volCtrl.value;
      const active = anySolo? m.solo : !m.mute;
      m.gainNode.gain.value = active ? base : 0;
    }
  }

  // grabación por canal (a clip en memoria)
  const recBtn = strip.querySelector('[data-rec]');
  recBtn.onclick = ()=>{
    if (!ch.rec){
      // iniciar worklet recorder por canal (WAV sincrónico)
      ch.rec = createWorkletRecorder(audio.ctx);
      ch.gainNode.connect(ch.rec.node); // TOMA post-fader
      ch.rec.start();
      recBtn.textContent='■ Detener Grabación';
      recBtn.style.background='linear-gradient(180deg,#330000,#661111)';
    } else {
      // detener, obtener WAV buffer, crear clip
      ch.rec.stop().then(({wavBlob, buffer})=>{
        // desconectar
        try{ ch.gainNode.disconnect(ch.rec.node); }catch{}
        ch.rec = null;
        recBtn.textContent='● Grabar Canal';
        recBtn.style.background='';

        // guardar clip
        const clip = {blob:wavBlob, buffer, loop:true, play:true, id: 'clip'+(ch.clips.length+1)};
        ch.clips.push(clip);
        addClipUI(ch, clip);
      });
    }
  };

  // eliminar canal
  strip.querySelector('[data-del]').onclick = ()=>{
    // parar reproducciones
    if (ch._playing){ for (const s of ch._playing) try{s.stop()}catch{}; ch._playing=[]; }
    // detener rec si activo
    if (ch.rec){ ch.rec.stop(); try{ch.gainNode.disconnect(ch.rec.node)}catch{}; ch.rec=null; }
    try{ ch.gainNode.disconnect(); }catch{}
    try{ ch.panNode.disconnect(); }catch{}
    strip.remove();
    delete audio.mixer[id];
  };

  return ch;
}

function addClipUI(ch, clip){
  const list = ch.el.querySelector('[data-clips]');
  const row = document.createElement('div'); row.className='clipItem';
  row.innerHTML = `
    <span>${clip.id}</span>
    <button class="btn small" data-toggle>${clip.play?'Pausar':'Repro'}</button>
    <button class="btn small" data-loop>${clip.loop?'Loop ON':'Loop OFF'}</button>
    <a class="btn small" data-dl>Descargar WAV</a>
    <button class="btn small" data-del>Eliminar</button>
  `;
  list.appendChild(row);

  row.querySelector('[data-toggle]').onclick = (e)=>{
    clip.play = !clip.play; e.target.textContent = clip.play?'Pausar':'Repro';
  };
  row.querySelector('[data-loop]').onclick = (e)=>{
    clip.loop = !clip.loop; e.target.textContent = clip.loop?'Loop ON':'Loop OFF';
  };
  row.querySelector('[data-dl]').onclick = (e)=>{
    const url = URL.createObjectURL(clip.blob);
    const a = document.createElement('a'); a.href = url; a.download = `${ch.name}_${clip.id}.wav`; a.click();
    setTimeout(()=> URL.revokeObjectURL(url), 1000);
  };
  row.querySelector('[data-del]').onclick = ()=>{
    ch.clips = ch.clips.filter(c=>c!==clip);
    row.remove();
  };
}

function maybeRemoveMixerIfUnused(id){
  // Si no hay notas de percusión para ese id y no hay clips ni ventana activa,
  // podríamos eliminar. Lo dejamos manual para no sorprender al usuario.
  // (Se mantiene el canal hasta que lo borres con "Eliminar Canal")
}

/* =========================
   Master Recording a WAV (Worklet)
   ========================= */
document.getElementById('masterRecBtn').onclick = ()=>{
  const btn = document.getElementById('masterRecBtn');
  const mr = audio.masterRecorder;
  if (!mr.recording){
    mr.start();
    btn.textContent='■ Detener Master (WAV)';
    btn.style.background='linear-gradient(180deg,#330000,#661111)';
  } else {
    mr.stop().then(({wavBlob})=>{
      btn.textContent='● Grabar Master (WAV)';
      btn.style.background='';
      const url = URL.createObjectURL(wavBlob);
      const a = document.createElement('a'); a.href = url; a.download = `master_${Date.now()}.wav`; a.click();
      setTimeout(()=> URL.revokeObjectURL(url), 1000);
    });
  }
};

/* =========================
   Worklet Recorder helper (WAV)
   ========================= */
function createWorkletRecorder(ctx){
  const state = {recording:false, chunks:[], node:null, resolve:null, bufferChunks:[]};
  // Crear módulo de worklet al vuelo
  const procCode = `
    class RecProc extends AudioWorkletProcessor{
      constructor(){ super(); this.recording=false; this.buf=[]; }
      process(inputs,outputs,params){
        const input = inputs[0];
        if (this.recording && input && input.length){
          const ch0 = input[0];
          // mezclar a mono sumando canales (si hay más)
          let mix = ch0.slice();
          for (let c=1;c<input.length;c++){
            const ch = input[c];
            for (let i=0;i<mix.length;i++){ mix[i] += ch[i]; }
          }
          // normalizar por número de canales
          const nCh = Math.max(1, input.length);
          for (let i=0;i<mix.length;i++){ mix[i] = mix[i] / nCh; }
          this.port.postMessage({type:'chunk', data:mix});
        }
        return true;
      }
    }
    registerProcessor('rec-proc', RecProc);
  `;
  const blobURL = URL.createObjectURL(new Blob([procCode],{type:'application/javascript'}));
  const start = async ()=>{
    if (!ctx.audioWorklet) return;
    if (!createWorkletRecorder._loaded){
      await ctx.audioWorklet.addModule(blobURL);
      createWorkletRecorder._loaded = true;
    }
    const node = new AudioWorkletNode(ctx, 'rec-proc', {numberOfInputs:1, numberOfOutputs:1, outputChannelCount:[2]});
    state.node = node;
    node.port.onmessage = (e)=>{
      if (e.data?.type==='chunk' && state.recording){
        state.chunks.push(e.data.data);
      }
    };
  };
  // iniciar de una (sin grabar aún)
  start();

  function encodeWavFromFloat32(float32arr, sampleRate){
    // PCM 16-bit mono
    const length = float32arr.length;
    const buffer = new ArrayBuffer(44 + length*2);
    const view = new DataView(buffer);

    function writeStr(offset, s){ for(let i=0;i<s.length;i++) view.setUint8(offset+i, s.charCodeAt(i)); }
    function write16(o,v){ view.setInt16(o, v, true); }
    function write32(o,v){ view.setUint32(o, v, true); }

    const numChannels = 1;
    const bitsPerSample = 16;
    const byteRate = sampleRate * numChannels * bitsPerSample/8;
    const blockAlign = numChannels * bitsPerSample/8;

    writeStr(0,'RIFF');
    write32(4, 36 + length*2);
    writeStr(8,'WAVE');
    writeStr(12,'fmt ');
    write32(16,16);
    write16(20,1); // PCM
    write16(22,numChannels);
    write32(24,sampleRate);
    write32(28,byteRate);
    write16(32,blockAlign);
    write16(34,bitsPerSample);
    writeStr(36,'data');
    write32(40,length*2);

    // data
    let offset = 44;
    for (let i=0;i<length;i++){
      let s = Math.max(-1, Math.min(1, float32arr[i]));
      view.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true);
      offset += 2;
    }
    return new Blob([view], {type:'audio/wav'});
  }

  return {
    node: state.node,
    recording:false,
    start(){
      state.chunks = [];
      this.recording = true;
      if (state.node) state.node.port.postMessage({type:'start'});
      // Flag en el procesador
      state.node?.port?.start?.();
      state.node && (state.node.port.onmessage = (e)=>{
        if (e.data?.type==='chunk' && this.recording){ state.chunks.push(e.data.data); }
      });
      // leve truco: set flag en processor
      state.node?.port?.postMessage({rec:true});
      state.node.processorRecording = true;
      state.node.port.onmessage = (e)=>{
        if (e.data?.type==='chunk' && this.recording){
          state.chunks.push(e.data.data);
        }
      };
      // activar grabación en el worklet
      state.node.port.postMessage({type:'toggle', on:true});
      state.node.recording = true;
      // También en propiedad del procesador (usamos port messages para chunks)
      state.node.port.postMessage = state.node.port.postMessage.bind(state.node.port);
      // Marcamos recording=true con un pequeño delay por seguridad
      if (state.node && state.node.processor){
        state.node.processor.recording = true;
      }
      // Señal al procesador (no tenemos propiedades, así que lo hacemos implícito)
      if (state.node) state.node.recording = true;
    },
    async stop(){
      this.recording = false;
      // concatenar chunks
      const sr = ctx.sampleRate;
      let totalLen = 0;
      for (const a of state.chunks) totalLen += a.length;
      const merged = new Float32Array(totalLen);
      let off = 0;
      for (const a of state.chunks){ merged.set(a, off); off += a.length; }
      const wavBlob = encodeWavFromFloat32(merged, sr);

      // También crear AudioBuffer para clips (facilita loop/play)
      const buf = ctx.createBuffer(1, merged.length, sr);
      buf.copyToChannel(merged, 0, 0);
      return {wavBlob, buffer:buf};
    }
  };
}

/* =========================
   Eventos de ventana / misc
   ========================= */
window.addEventListener('resize', ()=>{ resizeCanvas(); drawAll(); });

/* =========================
   ¡Precarga perezosa!
   ========================= */
(async function warmup(){
  // nada crítico aquí; todo es bajo demanda
})();

</script>
</body>
</html>
